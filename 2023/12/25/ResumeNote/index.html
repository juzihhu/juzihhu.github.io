<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>pytorch+gpu 环境配置 | JuZi</title><meta name="author" content="JuZi"><meta name="copyright" content="JuZi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="Summary 一、c++基础C++程序执行的内存空间结构  代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量**(数据段+BSS区)** 数据段（data）：用来存放显式初始化的全局变量或者静态（全局）变量，常量数据。 BSS段（Block Started by Symbol): 存储未初始化的全局变量或者静态（全局）变量。编译器给处理成0">
<meta property="og:type" content="article">
<meta property="og:title" content="pytorch+gpu 环境配置">
<meta property="og:url" content="http://juzihhu.github.io/2023/12/25/ResumeNote/index.html">
<meta property="og:site_name" content="JuZi">
<meta property="og:description" content="Summary 一、c++基础C++程序执行的内存空间结构  代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量**(数据段+BSS区)** 数据段（data）：用来存放显式初始化的全局变量或者静态（全局）变量，常量数据。 BSS段（Block Started by Symbol): 存储未初始化的全局变量或者静态（全局）变量。编译器给处理成0">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/p9/wallhaven-p9o51m.png">
<meta property="article:published_time" content="2023-12-25T12:37:37.535Z">
<meta property="article:modified_time" content="2023-12-25T12:17:56.878Z">
<meta property="article:author" content="JuZi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/p9/wallhaven-p9o51m.png"><link rel="shortcut icon" href="/img/tangerine.png"><link rel="canonical" href="http://juzihhu.github.io/2023/12/25/ResumeNote/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-2733661678797546',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c80b8bf4bfd944299945633ffd0b5478";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: JuZi","link":"链接: ","source":"来源: JuZi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'pytorch+gpu 环境配置',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-25 20:17:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/login/"><i class="fa-fw fa-solid fa-right-to-bracket"></i><span> 登录</span></a></div><div class="menus_item"><a class="site-page" href="/register/"><i class="fa-fw fa-solid fa-registered"></i><span> 注册</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/p9/wallhaven-p9o51m.png')"><nav id="nav"><span id="blog-info"><a href="/" title="JuZi"><span class="site-name">JuZi</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/login/"><i class="fa-fw fa-solid fa-right-to-bracket"></i><span> 登录</span></a></div><div class="menus_item"><a class="site-page" href="/register/"><i class="fa-fw fa-solid fa-registered"></i><span> 注册</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">pytorch+gpu 环境配置</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-25T12:37:37.535Z" title="发表于 2023-12-25 20:37:37">2023-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-25T12:17:56.878Z" title="更新于 2023-12-25 20:17:56">2023-12-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">简历问题总结</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">62k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>214分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="pytorch+gpu 环境配置"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>   
<meta name="referrer" content="no-referrer">

<p>Summary</p>
<h2 id="一、c-基础"><a href="#一、c-基础" class="headerlink" title="一、c++基础"></a>一、c++基础</h2><h3 id="C-程序执行的内存空间结构"><a href="#C-程序执行的内存空间结构" class="headerlink" title="C++程序执行的内存空间结构"></a>C++程序执行的内存空间结构</h3><p><img src="https://gitee.com/juzihhu/image_bed/raw/master/img/202308152348046.png" alt="image-20230815234807866"></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量**(数据段+BSS区)**<ul>
<li>数据段（data）：用来存放显式初始化的全局变量或者静态（全局）变量，常量数据。</li>
<li>BSS段（Block Started by Symbol): 存储未初始化的全局变量或者静态（全局）变量。编译器给处理成0；</li>
</ul>
</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收;堆由于new&#x2F;delete分配空间不连续，会产生碎片</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等;堆由于new&#x2F;delete分配空间不连续，会产生碎片</li>
</ul>
<h3 id="在main执行之前和之后执行的代码可能是什么"><a href="#在main执行之前和之后执行的代码可能是什么" class="headerlink" title="在main执行之前和之后执行的代码可能是什么"></a>在main执行之前和之后执行的代码可能是什么</h3><p><strong>main函数执行之前</strong>:</p>
<p>主要就是初始化系统相关资源：设置栈指针,进行所有全局对象的构造以及初始化工作, 将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</p>
<p>C++中，<code>argc</code>和<code>argv</code>是命令行参数的传递机制，用于向程序传递参数。</p>
<ul>
<li><code>argc</code>是指传递给程序的参数个数，包括程序名本身。它是一个整数类型变量。</li>
<li><code>argv</code>是一个指向字符指针数组的指针，每个字符指针指向一个传递给程序的参数字符串。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of arguments: &quot;</span> &lt;&lt; argc &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Argument &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; argv[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main函数执行之后</strong>：</p>
<p>全局对象的析构函数会在main函数之后执行,对全局变量和全局对象进行销毁操作</p>
<p>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main 之后执行;</p>
<h3 id="define-、inline、typedef-的区别"><a href="#define-、inline、typedef-的区别" class="headerlink" title="define 、inline、typedef 的区别"></a>define 、inline、typedef 的区别</h3><p><strong>define</strong>：定义预编译时处理的宏，只是简单的字符串替换，没有类型检查</p>
<p>是在编译的预处理段起作用</p>
<p>可以用来防止头文件重复引用</p>
<p>不分配内存，给出的是立即数，有多少次使用就进行多少次替换</p>
<p><strong>typedef</strong>：用来给现有的类型定义一个新的名称，方便程序中使用这种类型。<br>有对应的数据类型，是要进行判断的</p>
<p>是在编译、运行的时候起作用</p>
<p>在静态存储区中分配空间，在程序运行过程中内存中只有一个拷⻉</p>
<p><strong>inline：</strong> C++ 中的函数修饰符，用来告诉编译器将函数内容直接嵌入到调用处，减少函数调用的开销。</p>
<p>inline是先将内联函数编译完成生成了函数体直接插入被调用的地方，减少了ܴ压栈，跳转和返回的操作。没有普通函数调用时额外开销；<br>内联函数是一种特的函数，会进行类型检查；<br>对编译器的一种请求，编译器有可能拒绝绝这种请求</p>
<h3 id="include的作用"><a href="#include的作用" class="headerlink" title="#include的作用"></a>#include的作用</h3><p>#include 是一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%A2%84%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">预处理</a>指令，在编译代码之前，将指定的头文件的内容插入到当前文件中</p>
<h3 id="new-与-malloc"><a href="#new-与-malloc" class="headerlink" title="new 与 malloc"></a>new 与 malloc</h3><p>因为<code>new</code>是关键字，我们本应该无法修改<code>new</code>分配内存的方式。由于<code>new</code>在分配内存时，调用<code>operator new</code>函数,它会尝试从堆中分配指定大小的内存块，并返回指向分配内存的指针。如果分配成功，则返回一个非空指针；如果分配失败，无法满足内存需求，则返回一个空指针。</p>
<p>当 <code>operator new</code> 无法分配所需的内存时，它有两种处理方式：</p>
<ol>
<li>返回空指针：在 C++98&#x2F;03 中，<code>operator new</code> 在分配失败时返回空指针，表示内存分配失败。</li>
<li>抛出 <code>std::bad_alloc</code> 异常：在 C++11 及以后的版本中，<code>operator new</code> 在分配失败时抛出 <code>std::bad_alloc</code> 异常，表示内存分配失败。</li>
</ol>
<p>**C++ Primer 一书上说这不是重载 new 和 delete 表达式（如 <code>operator=</code> 就是重载 <strong>&#x3D;</strong> 操作符），因为 new 和 delete 是不允许重载的; </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">C</th>
<th>c++</th>
</tr>
</thead>
<tbody><tr>
<td align="center">性质</td>
<td align="center">malloc&#x2F;free是函数</td>
<td>new&#x2F;delete是操作符</td>
</tr>
<tr>
<td align="center">初始化</td>
<td align="center">malloc不可以初始化</td>
<td>new可以初始化</td>
</tr>
<tr>
<td align="center">开辟空间的位置</td>
<td align="center">malloc开辟的空间在堆区</td>
<td>new开辟的空间在自由存储区</td>
</tr>
<tr>
<td align="center">开辟空间的大小</td>
<td align="center">malloc开辟空间时需要指定空间大小</td>
<td>new开辟空间时只需要类型名，由编译器自己计算大小</td>
</tr>
<tr>
<td align="center">成功返回值</td>
<td align="center">malloc申请成功返回void*型空间，需要使用时强转成其他类型，失败返回NULL</td>
<td>new申请成功返回对象指针，失败则抛出异常</td>
</tr>
<tr>
<td align="center">扩容</td>
<td align="center">malloc开辟的空间如果不够用，可以使用realloc扩容</td>
<td>new没有直接的扩容方式</td>
</tr>
<tr>
<td align="center">是否调用构造&#x2F;析构</td>
<td align="center">new在申请空间时，先调用malloc开辟空间，再调用构造函数进行初始化，在delete时会先调用析构函数清理对象，然后调用free释放空间；<code>new</code>运算符具有异常处理机制，可在发生错误时抛出异常，而<code>malloc</code>不具备此功能</td>
<td></td>
</tr>
</tbody></table>
<p><code>new</code>是一个运算符,<code>new操作符本身是不能被重载的，但是可通过调用</code>operator new()&#96;函数来改变new操作符的行为，分配内存，然后<strong>调用了类的构造函数来创建对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes using operator new&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">void</span>* ptr = std::<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::bad_alloc&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Deallocating memory using operator delete&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destroying MyClass&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;MyClass with value &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//new操作符会调用C++运行库中的operator new函数分配一段足够大小的内存</span></span><br><span class="line">    <span class="comment">//分配内存后，new操作符会调用对象的构造函数初始化对象</span></span><br><span class="line">    MyClass* ptr = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">42</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="comment">//ptr是之前分配的内存空间的地址，该语句会先调用ptr指向的对象的析构函数进行清理，</span></span><br><span class="line">    <span class="comment">//然后再调用C++运行库中的 operator delete函数释放内存。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果是带有⾃定义析构函数的类类型，⽤ new [] 来创建类对象数组，⽽⽤ delete来释放会发<br>⽣什么?</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line">A* pAa = <span class="keyword">new</span> A[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> pAa;</span><br></pre></td></tr></table></figure>

<p>那么 delete pAa; 做了两件事：</p>
<ol>
<li>调⽤⼀次 pAa 指向的对象的析构函数</li>
<li>调⽤ operator delete(pAa);释放内存</li>
</ol>
<p>显然，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。<br>应该用：delete[] pAa;</p>
<p>我们经常要用到动态分配一个数组，也许是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *psa = <span class="keyword">new</span> string[<span class="number">10</span>];      <span class="comment">//array of 10 empty strings</span></span><br><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];           <span class="comment">//array of 10 uninitialized ints</span></span><br></pre></td></tr></table></figure>

<p>上面在申请一个数组时都用到了 <code>new []</code> 这个表达式来完成，按照我们上面讲到的 new 和 delete 知识，第一个数组是 string 类型，分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素；第二个是申请具有内置类型的数组，分配了存储 10 个 int 对象的内存空间，但并没有初始化。</p>
<p>如果我们想释放空间了，可以用下面两条语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] psa;</span><br><span class="line"><span class="keyword">delete</span> [] pia;</span><br></pre></td></tr></table></figure>

<p>都用到 <code>delete []</code> 表达式，注意这地方的 [] 一般情况下不能漏掉！我们也可以想象这两个语句分别干了什么：第一个对 10 个 string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间；第二个因为是内置类型不存在析构函数，直接释放为 10 个 int 型分配的所有内存空间。</p>
<p>[浅谈 C++ 中的 new&#x2F;delete 和 new<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hazir/p/new_and_delete.html">]&#x2F;delete[] - hazir - 博客园 (cnblogs.com)</a></p>
<h3 id="malloc线程安全吗"><a href="#malloc线程安全吗" class="headerlink" title="malloc线程安全吗"></a>malloc线程安全吗</h3><p>在标准 C 库中，<code>malloc</code> 函数并不是线程安全的。多线程环境下，如果多个线程同时调用 <code>malloc</code> 分配内存，可能会导致竞争条件和内存相关的问题。为了在多线程环境下保证 <code>malloc</code> 的线程安全，可以采用以下几种方法：</p>
<ol>
<li>使用<strong>互斥锁</strong>：在 <code>malloc</code> 函数的实现中使用互斥锁来保护关键数据结构，确保只有一个线程可以同时进入 <code>malloc</code> 函数。这样可以避免多个线程同时访问分配内存的数据结构，解决竞争条件。</li>
<li>使用<strong>线程局部存储</strong>：在一些 <code>malloc</code> 实现中，可以使用线程局部存储（Thread Local Storage，TLS）来避免多线程之间的竞争。每个线程拥有自己独立的内存池，从而避免了竞争条件。</li>
<li>使用多个内存池：为了减少锁竞争，可以为每个线程分配一个独立的内存池。当线程需要分配内存时，直接从自己的内存池中分配，不会与其他线程产生竞争。</li>
<li>使用内存池和自由列表：在一些内存管理库中，会使用内存池和自由列表的技术来提高多线程下 <code>malloc</code> 的性能和线程安全性。每个线程拥有自己的内存池，并且会维护一个自由列表来管理已经释放的内存块，避免频繁调用系统的内存分配和释放函数。</li>
<li>使用其他的内存分配算法：除了标准的 <code>malloc</code>，还可以考虑使用其他的内存分配算法，如 tcmalloc、jemalloc 等，它们通常都提供了更高效和线程安全的内存管理功能。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 定义一个互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">safe_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 使用互斥锁保护 malloc 操作</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_free</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 使用互斥锁保护 free 操作</span></span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在多个线程中调用 safe_malloc 和 safe_free</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">void</span>* ptr = <span class="built_in">safe_malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; allocated memory at: &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">safe_free</span>(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">5</span>;</span><br><span class="line">    std::thread threads[numThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(threadFunction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code>是C++中的一个关键字，<strong>用于告诉编译器不要对该变量进行优化，每次使用这个变量的时候都从内存中重新读取数据，以避免一些意外的行为</strong>。主要用于多线程编程、硬件编程等场景中。</p>
<p>具体来说，当变量被声明为<code>volatile</code>时，编译器不会对其进行优化，例如不会将多个读操作合并为一个，也不会将多个写操作合并为一个。这是因为<code>volatile</code>变量可能会被其他线程或外部设备修改，编译器无法预知其值，因此不能进行优化。</p>
<p>另外，<code>volatile</code>还可以用于防止编译器过度优化代码。例如，某些情况下，编译器可能会认为某个计算结果是不会改变的，从而将其缓存起来，导致实际运行时结果错误。在这种情况下，可以将变量声明为<code>volatile</code>，以告诉编译器该变量可能会被修改，从而防止过度优化。</p>
<p>下面是一个简单的例子，用于演示<code>volatile</code>的作用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;flag is true&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，主线程和子线程都访问了同一个变量<code>flag</code>。如果不将<code>flag</code>声明为<code>volatile</code>，则编译器可能会将其缓存起来，从而导致子线程无法及时获取到<code>flag</code>的修改。将<code>flag</code>声明为<code>volatile</code>后，可以确保子线程可以及时获取到<code>flag</code>的修改，从而正常退出循环。</p>
<h3 id="一个函数f-int-a-int-b-的b和a的地址关系？"><a href="#一个函数f-int-a-int-b-的b和a的地址关系？" class="headerlink" title="一个函数f(int a, int b)的b和a的地址关系？"></a>一个函数f(int a, int b)的b和a的地址关系？</h3><p>在 C++ 中，函数的参数在栈上以参数的逆序（从右到左）依次入栈，也就是说，函数的第一个参数 <code>a</code> 先入栈，紧接着第二个参数 <code>b</code> 入栈。所以在函数 <code>f(int a, int b)</code> 中，<code>b</code> 的地址会比 <code>a</code> 的地址更靠近栈顶。</p>
<p>具体来说，在函数 <code>f</code> 被调用时，编译器会在栈上为参数 <code>a</code> 和 <code>b</code> 分配空间，并按照参数逆序依次将它们的值压入栈中。栈的增长方向是从高地址到低地址，因此 <code>b</code> 的地址会比 <code>a</code> 的地址更小。</p>
<h3 id="前置-与后置"><a href="#前置-与后置" class="headerlink" title="前置++与后置++"></a>前置++与后置++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置++</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="comment">//先++</span></span><br><span class="line">    m_Num++;</span><br><span class="line">    <span class="comment">//再返回</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置++ 返回的是值不是引用</span></span><br><span class="line"><span class="comment">// int作为占位参数</span></span><br><span class="line"><span class="type">const</span> MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">//先返回</span></span><br><span class="line">    MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">    ++<span class="keyword">this</span>-&gt;m_Num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后置返回对象而不是引⽤</strong>：因为后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁，如果返回引⽤,函数调用结束后临时对象被销毁而报错；a++是一个表达式不可以作为左值</p>
<p><strong>处理⽤户的⾃定义类型</strong>: 最好使⽤前置++，因为他不会创建临时对象，进⽽不会带来构造和析构⽽造成的格外开销</p>
<p>在C++中，左值是可以出现在赋值语句左侧的表达式，左值必须是一个可以被修改的存储位置，如变量、数组元素、结构体成员等</p>
<h3 id="左值引用与右值引用"><a href="#左值引用与右值引用" class="headerlink" title="左值引用与右值引用"></a>左值引用与右值引用</h3><p>左值引用和右值引用是C++11中引入的概念，用于支持移动语义和完美转发。在理解左值引用和右值引用之前，我们先需要理解左值和右值的概念。</p>
<p><strong>左值（Lvalue</strong>指的是一个对象（变量）的标识符，它具有持久的内存地址，可以取地址（&amp;）并且可以被赋值。</p>
<p><strong>右值（Rvalue</strong>指的是那些不能被取地址的表达式，比如字面常量、临时对象和表达式求值的结果等。</p>
<p>在C++中，左值引用（Lvalue Reference）使用&amp;符号来声明，用于引用一个左值，而右值引用（Rvalue Reference）使用&amp;&amp;符号来声明，用于引用一个右值。</p>
<p>下面是一个简单的示例，说明左值引用和右值引用的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">c++Copy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span> </span>&#123; <span class="comment">// 左值引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;&amp;a)</span> </span>&#123; <span class="comment">// 右值引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">func</span>(a); <span class="comment">// 调用左值引用版本</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">2</span>); <span class="comment">// 调用右值引用版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，当我们调用<code>func(a)</code>时，会调用左值引用版本的函数，因为a是一个左值。当我们调用<code>func(2)</code>时，会调用右值引用版本的函数，因为2是一个右值。</p>
<p>右值引用是C++11中引入的一种新的引用类型，它可以绑定到<strong>右值，例如临时对象、字面量</strong>等，右值引用主要用于支持移动语义和完美转发。移动语义可以避免不必要的内存拷贝，提高程序的性能。完美转发可以保留参数的类型信息，避免参数被隐式转换，提高代码的安全性和可维护性。</p>
<p>右值<strong>允许程序员更加细粒度的处理对象拷贝时的内存分配问题，提高了对临时对象和不需要的对象的利用率</strong>；</p>
<h3 id="移动语义std-move"><a href="#移动语义std-move" class="headerlink" title="移动语义std::move()"></a>移动语义std::move()</h3><p>std::move是<strong>将对象的状态或者所有权从一个对象转移到另一个对象</strong>，避免不必要内存拷贝;</p>
<p>std::move函数可以显示地将左值转换为右值引用;</p>
<p>使用move函数转交unique_ptr的所有权</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">56</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up_int1</span><span class="params">(p1)</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; up_int2= <span class="built_in">move</span>(up_int1);<span class="comment">//转交所有权（法1）</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt; p2(p1.release()); //转交所有权（法2）</span></span><br></pre></td></tr></table></figure>

<p><code>std::move()</code> 的底层操作非常简单，它的实现只是将传入的对象转换为右值引用，即将左值引用转换为右值引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><code>T&amp;&amp;</code> 表示 <code>std::move()</code> 接受一个右值引用或一个将亡值（可以被移动的对象）作为参数。</li>
<li><code>std::remove_reference&lt;T&gt;::type</code> 用于去除 <code>T</code> 的引用，得到对象的实际类型。</li>
<li><code>static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)</code> 将对象 <code>t</code> 强制转换为右值引用。</li>
</ol>
<p><strong>unique_ptr 独占指针，只能使用<code>std::move()</code>转移拥有权</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;smart boy!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>()&#123;</span><br><span class="line">         std::cout&lt;&lt;<span class="string">&quot;destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::unique_ptr&lt;Entity&gt; temp)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;foo \n&quot;</span>;</span><br><span class="line">    temp-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. p.get()慎用，返回p中保存的指针</span></span><br><span class="line">    <span class="comment">// 2. p-&gt;mem 等价于 (*p).mem</span></span><br><span class="line">    <span class="comment">// 3. *p 解引用，获得它指向的对象</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;main\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 创建只支持new</span></span><br><span class="line">       <span class="comment">// 不支持p2(p1)</span></span><br><span class="line">       <span class="comment">// 不支持p2 = p1</span></span><br><span class="line">       <span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">       <span class="built_in">foo</span>(std::<span class="built_in">move</span>(p));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;gg\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main</span></span><br><span class="line"><span class="comment">constructor</span></span><br><span class="line"><span class="comment">foo </span></span><br><span class="line"><span class="comment">smart boy!</span></span><br><span class="line"><span class="comment">destructor</span></span><br><span class="line"><span class="comment">gg</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="完美转发std-forward-lt-gt"><a href="#完美转发std-forward-lt-gt" class="headerlink" title="完美转发std::forward&lt;&gt;"></a>完美转发std::forward&lt;&gt;</h3><p>完美转发可以在函数调用过程中保留参数的类型信息，避免参数被隐式转换，提高代码的安全性和可维护性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue ref&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue ref&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123; </span><br><span class="line">    <span class="built_in">print</span>(v);<span class="comment">//v此时已经是个左值了,永远调用左值版本的print</span></span><br><span class="line">    <span class="built_in">print</span>(std::forward&lt;T&gt;(v)); <span class="comment">//本文的重点</span></span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">move</span>(v)); <span class="comment">//永远调用右值版本的print</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;======================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(x); <span class="comment">//实参为左值</span></span><br><span class="line">    <span class="built_in">testForward</span>(std::<span class="built_in">move</span>(x)); <span class="comment">//实参为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序的运行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lvalue ref</span><br><span class="line">Lvalue ref</span><br><span class="line">Rvalue ref</span><br><span class="line">======================</span><br><span class="line">Lvalue ref</span><br><span class="line">Rvalue ref</span><br><span class="line">Rvalue ref</span><br><span class="line">======================</span><br></pre></td></tr></table></figure>

<p>当传入函数的参数是一个右值，而你要在函数内使用此参数时，必定会被转换成左值(因为你用了个形参来接收他)，也就是这时候这个参数丢失了他本身的语义。std::forward 的作用就是“完美”的保持这个参数的语义；</p>
<h3 id="MyString实现"><a href="#MyString实现" class="headerlink" title="MyString实现"></a>MyString实现</h3><p>例如，我们可以通过定义右值引用参数来实现移动语义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//explicit关键字，以避免隐式转换</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> : m_length(std::strlen(str)), m_data(new char[m_length + <span class="number">1</span>]) &#123;</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) : <span class="built_in">m_length</span>(other.m_length), <span class="built_in">m_data</span>(<span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>]) &#123;</span><br><span class="line">    std::<span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动构造函数 避免内存拷贝</span></span><br><span class="line">  <span class="comment">//noexcept关键字，以表明该函数不会抛出异常</span></span><br><span class="line">  <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">m_data</span>(other.m_data), <span class="built_in">m_length</span>(other.m_length) &#123;</span><br><span class="line">    other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    other.m_length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回指向字符串的指针</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* m_data;</span><br><span class="line">  std::<span class="type">size_t</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 MyString 对象的函数</span></span><br><span class="line"><span class="function">MyString <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MyString</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function">MyString <span class="title">str2</span><span class="params">(foo())</span></span>; <span class="comment">// 调用移动构造函数</span></span><br><span class="line">  std::cout &lt;&lt; str1.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="string的基本用法"><a href="#string的基本用法" class="headerlink" title="string的基本用法"></a>string的基本用法</h3><p><strong>需要包含头文件&lt;string.h&gt;或<cstring></cstring></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(p, p1) 将p1拷贝到<span class="function">p</span></span><br><span class="line"><span class="function"><span class="title">strncpy</span><span class="params">(p, p1, n)</span> 将p1中前n个字符拷贝到p</span></span><br><span class="line"><span class="function"><span class="title">strcat</span><span class="params">(p, p1)</span> 将p1接到p后面</span></span><br><span class="line"><span class="function"><span class="title">strncat</span><span class="params">(p, p1, n)</span> 将p1中前n个字符接到p后面</span></span><br><span class="line"><span class="function"><span class="title">strstr</span><span class="params">(p, p1)</span> 查找字符串，返回子串p1在p中首次出现位置的指针. 如果没有找到子串, 则返回<span class="literal">NULL</span>.</span></span><br><span class="line"><span class="function">字符串到数值类型的转换</span></span><br><span class="line"><span class="function"><span class="title">atoi</span><span class="params">(p)</span> 字符串转换到 <span class="type">int</span> 整型</span></span><br><span class="line"><span class="function"><span class="title">atof</span><span class="params">(p)</span> 字符串转换到 <span class="type">double</span> 符点数</span></span><br><span class="line"><span class="function"><span class="title">atol</span><span class="params">(p)</span> 字符串转换到 <span class="type">long</span> 整型</span></span><br><span class="line"><span class="function">字符检查</span></span><br><span class="line"><span class="function"><span class="title">isalpha</span><span class="params">()</span> 检查是否为字母字符</span></span><br><span class="line"><span class="function"><span class="title">isupper</span><span class="params">()</span> 检查是否为大写字母字符</span></span><br><span class="line"><span class="function"><span class="title">islower</span><span class="params">()</span> 检查是否为小写字母字符</span></span><br><span class="line"><span class="function"><span class="title">isdigit</span><span class="params">()</span> 检查是否为数字</span></span><br><span class="line"><span class="function"><span class="title">isspace</span><span class="params">()</span> 检查是否为空格类型字符</span></span><br><span class="line"><span class="function"><span class="title">ispunct</span><span class="params">()</span> 检查是否为标点符号</span></span><br><span class="line"><span class="function"><span class="title">isalnum</span><span class="params">()</span> 检查是否为字母和数字</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><code>size_t find ( const string&amp; str, size_t pos = 0 ) const;</code></p>
<p>返回str在字符串中第一次出现的位置下标,pos为初始查找位置;</p>
<p><code>basic_string substr( size_type index, size_type num = npos );</code></p>
<p><strong>substr()函数</strong>返回本字符串的一个子串，从index开始，长num个字符;</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fraction-addition-and-subtraction/">https://leetcode.cn/problems/fraction-addition-and-subtraction/</a></p>
<p>给定一个表示分数加减运算的字符串 <code>expression</code> ，你需要返回一个字符串形式的计算结果。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fractionAddition</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> fenzi=<span class="number">0</span>,fenmu=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>,n=expression.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(index&lt;n)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x1=<span class="number">0</span>,sign=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(expression[index]==<span class="string">&#x27;-&#x27;</span>||expression[index]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                sign=expression[index]==<span class="string">&#x27;-&#x27;</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;n&amp;&amp;<span class="built_in">isdigit</span>(expression[index]))&#123;</span><br><span class="line">                x1=x1*<span class="number">10</span>+expression[index]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            x1=sign*x1;</span><br><span class="line">            ++index;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;x1&lt;&lt;&quot; &quot;;</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> y1=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;n&amp;&amp;<span class="built_in">isdigit</span>(expression[index]))&#123;</span><br><span class="line">                y1=y1*<span class="number">10</span>+expression[index]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;index&lt;&lt;&quot; index-&gt; &quot;&lt;&lt;expression[index]&lt;&lt;&quot; &quot;&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">            fenzi=fenzi*y1+x1*fenmu; </span><br><span class="line">            fenmu=fenmu*y1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fenzi==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0/1&quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g=<span class="built_in">gcd</span>(<span class="built_in">abs</span>(fenzi),fenmu);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(fenzi/g)+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">to_string</span>(fenmu/g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>在C++中，explicit关键字可以用于修饰构造函数或者转换函数，表示禁止编译器进行隐式转换。如果一个构造函数被explicit修饰，则该构造函数不能用于隐式转换，只能用于显式转换</p>
<p>例如，对于下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A a)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">A</span>(<span class="number">10</span>)); <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用<code>func(10)</code>时，由于A的构造函数被explicit修饰，编译器不会将10隐式转换为A类型，因此会报错。而调用<code>func(A(10))</code>时，由于是显式转换，因此可以通过编译</p>
<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">myStrCopy</span><span class="params">(<span class="type">char</span>* destStr, <span class="type">const</span> <span class="type">char</span>* srcStr )</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(destStr != <span class="literal">nullptr</span> &amp;&amp; srcStr != <span class="literal">nullptr</span>); <span class="comment">// 检查指针是否为空</span></span><br><span class="line">    <span class="type">char</span>* p = destStr;</span><br><span class="line">    <span class="keyword">while</span> (*srcStr != <span class="string">&#x27;\0&#x27;</span>) *p++ = *srcStr++；</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> destStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意返回的是字符串的起始地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(dest != <span class="literal">nullptr</span> &amp;&amp; src != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">char</span>* p = dest;</span><br><span class="line">  <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    ++p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    *p++ = *src++;</span><br><span class="line">  &#125;</span><br><span class="line">  *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指向指针的引用-x2F-指针"><a href="#指向指针的引用-x2F-指针" class="headerlink" title="指向指针的引用&#x2F;指针"></a>指向指针的引用&#x2F;指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory1</span><span class="params">(<span class="type">char</span>* p)</span></span>&#123;</span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetMemory1</span>(str);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数<code>GetMemory1</code>中，参数<code>p</code>是传递进来的指针的拷贝，指针<code>p</code>的改变不会影响原始指针<code>str</code>，在分配内存的同时对<code>p</code>进行修改在<code>GetMemory1</code>函数结束后已经失效。因此，该代码会导致未定义的行为，因为尝试将值复制到未分配内存的指针<code>str</code>中，可能会导致崩溃或者出现意想不到的结果。</p>
<p>为了解决此问题，可以改为接收指向指针的引用，或者返回所分配的指针。如下：</p>
<p>接收指向指针的引用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="type">char</span>*&amp; p)</span></span>&#123;</span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetMemory2</span>(str);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回所分配的指针:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">GetMemory3</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test3</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="built_in">GetMemory3</span>();</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，使用<code>malloc</code>分配的内存应该在不使用时释放，以避免内存泄漏</p>
<p>这是一个使用指向指针的指针修改的示例代码，符合Google C++规范：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="type">char</span>** p)</span> </span>&#123;</span><br><span class="line">  *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span>* str = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">GetMemory2</span>(&amp;str);</span><br><span class="line">  <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>GetMemory2()</code>函数使用指向指针的指针<code>char**</code>作为参数，以便可以修改指针的值。在函数内部，我们使用<code>malloc()</code>函数分配了100个字节的内存，并将其赋值给<code>*p</code>。在<code>Test2()</code>函数中，我们声明了一个指向字符的指针<code>char* str</code>，并将其初始化为<code>nullptr</code>。然后，我们调用<code>GetMemory2()</code>函数，并将<code>&amp;str</code>传递给它，以便可以修改指针的值。最后，我们使用<code>strcpy()</code>函数将字符串”hello world”复制到分配的内存中，并使用<code>printf()</code>函数打印该字符串</p>
<h3 id="a-和-int-a-x3D-b-在C-中是否是线程安全"><a href="#a-和-int-a-x3D-b-在C-中是否是线程安全" class="headerlink" title="a++ 和 int a &#x3D; b 在C++中是否是线程安全"></a>a++ 和 int a &#x3D; b 在C++中是否是线程安全</h3><p>a++ 和 int a &#x3D; b 都不是线程安全的</p>
<p>a++：从C&#x2F;C++语法的级别来看，这是⼀条语句，应该是原⼦的；但从编译器得到的汇编指令来看，其实不是原⼦的。<br>其⼀般对应三条指令，⾸先将变量a对应的内存值搬运到某个存器（如eax）中，然后将该存器中的值⾃增1，再将该寄存器中的值运回a代表的内存中；如果多个线程同时对同一个变量进行自增操作，就可能导致竞争条件（RaceCondition），从而导致不确定的结果。</p>
<p>int a &#x3D; b; 从C&#x2F;C++语法的级别来看，这是条语句应该是原⼦的；但从编译器得到的汇编指令来看，由于现在计算机CPU架构体系的限制，数据不能直接从内存某处运到内存另外⼀处，必须借寄存器中转，因此这条语句⼀般对应两条计算机指令，即将变量b的值运到某个寄存器（如eax）中，再从该寄存器搬运到变量a的内存地址中：<br>mov eax, dword ptr [b]<br>mov dword prt [a], eax</p>
<p>多个线程在执⾏这两条指令时，某个线程可能会在第⼀条指令执⾏完毕后被剥夺CPU时间⽚，切换到另⼀个线程⽽出现不确定的情况。</p>
<p><strong>解决办法： C++11新标准提供了对整形变量原⼦操作的相关库，即std::atomic，这是⼀个模板类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">atomic</span>:</span><br><span class="line"><span class="comment">// 初始化1</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; value;</span><br><span class="line">value = <span class="number">99</span>;</span><br><span class="line"><span class="comment">// 初始化2</span></span><br><span class="line"><span class="comment">// 下⾯代码在Linux平台上⽆法编译通过（指在gcc编译器）</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; value = <span class="number">99</span>;</span><br><span class="line"><span class="comment">// 出错的原因是这⾏代码调⽤的是std::atomic的拷⻉构造函数</span></span><br><span class="line"><span class="comment">// ⽽根据C++11语⾔规范，std::atomic的拷⻉构造函数使⽤=delete标记禁⽌编译器⾃动⽣成</span></span><br><span class="line"><span class="comment">// g++在这条规则上遵循了C++11语⾔规范</span></span><br></pre></td></tr></table></figure>

<p>为了确保线程安全，可以使用互斥锁（Mutex）、信号量（Semaphore）等机制来保护关键代码段，同时只允许一个线程进入。这样可以避免多个线程同时访问和修改同一个变量，从而确保安全性和正确性</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong><code>static</code> 关键字的不同用法：</strong></p>
<ul>
<li><strong>局部静态变量（Static Local Variables）：</strong> 在函数内部声明的变量可以使用 <code>static</code> 关键字进行修饰。这样的变量在&#x3D;&#x3D;整个程序的生命周期内只会被初始化一次&#x3D;&#x3D;，并且存储在&#x3D;&#x3D;静态存储区&#x3D;&#x3D;。它在函数调用结束后并不会被销毁，下次函数再次调用时会继续存在。</li>
<li><strong>全局静态变量（Static Global Variables）：</strong> &#x3D;&#x3D;在全局范围内声明的变量，也就是在任何函数外部声明的变量&#x3D;&#x3D;，可以使用 <code>static</code> 关键字进行修饰。这样的变量作用域仅限于声明它的文件，也就是说它在其他文件中是不可见的。同样，它也存储在静态存储区。</li>
<li><strong>静态成员变量（Static Member Variables）：</strong> 在类内部声明的静态成员变量&#x3D;&#x3D;属于整个类而不是类的实例&#x3D;&#x3D;。这些变量在所有<code>类的实例之间共享，存储在静态存储区</code>。</li>
<li><strong>静态成员函数（Static Member Functions）：</strong> <code>类中的静态成员函数不属于任何类的实例，因此它不访问任何实例特定的数据</code>。&#x3D;&#x3D;静态成员函数可以被直接通过类名调用，而不需要创建类的实例&#x3D;&#x3D;。(单例模式)</li>
</ul>
<p><strong>局部静态变量与全局静态变量区别：</strong> 两者的作用域不一样，前者的作用域局限于声明它们的函数，后者的作用域限于整个文件；</p>
<p><strong><code>static</code> 线程安全性：</strong></p>
<p><code>static</code> 变量本身并不是线程安全或线程不安全的，它的线程安全性取决于你的代码如何使用它。在多线程环境中，多个线程访问和修改同一个 <code>static</code> 变量可能会引发竞争条件和数据不一致的问题。为了保证线程安全性，你可能需要使用互斥锁等机制来保护 <code>static</code> 变量的访问和修改。</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>C++中的虚函数是一种在基类中声明并在派生类中重写的函数。它们用于实现多态性，即通过基类的指针或引用调用派生类的方法，在运行时根据对象的实际类型来调用相应的函数；</p>
<h3 id="析构函数是不是必须要为虚函数？"><a href="#析构函数是不是必须要为虚函数？" class="headerlink" title="析构函数是不是必须要为虚函数？"></a>析构函数是不是必须要为虚函数？</h3><p><strong>析构函数可以是虚函数，也可以不是虚函数。</strong></p>
<p>析构函数为虚函数的情况：<strong>继承</strong></p>
<p>当父类指针释放子类对象时，<code>如果父类的析构函数不是虚函数，子类的析构函数可能调不到</code>（指针类型是父类，所以直接调用父类的析构函数），从而导致<strong>内存泄漏</strong>。</p>
<p>既然这样，是不是C++默认的析构函数设计成虚函数更合适？答案是否定的，<strong>虚函数需要额外的虚函数表和虚表指针，占用额外的内存</strong>，<code>如果类的设计不考虑继承，把析构函数设置成虚函数无疑是浪费内存。</code></p>
<h3 id="为什么构造函数不能是虚函数"><a href="#为什么构造函数不能是虚函数" class="headerlink" title="为什么构造函数不能是虚函数"></a>为什么构造函数不能是虚函数</h3><ul>
<li><p>构造函数不能是虚函数的主要原因是，它们在对象被创建时执行，而虚函数是在对象已经被创建后才能被调用。如果将构造函数声明为虚函数，可能会导致程序的行为不确定和程序崩溃等问题。</p>
</li>
<li><p>因为对象在被创建时，还没有被指针所指定，也就不存在虚表，所以构造函数不能是虚函数。此外，虚函数的调用是由虚表指针控制的，而构造函数在创建对象时不需要虚表。</p>
</li>
<li><p>另外，构造函数的目的是初始化对象的数据成员，为对象的使用做好准备。由于构造函数不能被继承，因此也没有意义把构造函数声明为虚函数。</p>
</li>
</ul>
<p>总之，构造函数不能是虚函数，虚函数的调用是由已经创建好的对象来调用的，而构造函数则是用于对象创建的初始化工作，两者间存在本质差异。</p>
<p><strong>虚函数表指针</strong>是一个指向虚函数表的指针，它在类的构造函数中被初始化，指向类的虚函数表。</p>
<p><strong>虚函数表</strong>是一个存储类中所有虚函数地址的数组，它在编译时被创建，存在于程序的只读数据区。¹</p>
<ul>
<li>编译期:对含虚函数的类(如基类)创建虚函数表；</li>
<li>链接期:对继承体系中每个类创建自己的虚函数表,并在其中填入虚函数地址,包括继承自基类的虚函数。</li>
<li><strong>虚函数表指针存储于对象中,其存储区域取决于对象的存储区域；</strong></li>
</ul>
<p>因此，虚函数表指针在类的构造函数中被初始化，而虚函数表是在编译时被创建，存在于程序的只读数据区。¹²</p>
<h3 id="如何从虚函数表中查找到-vfunc1-的地址？"><a href="#如何从虚函数表中查找到-vfunc1-的地址？" class="headerlink" title="如何从虚函数表中查找到 vfunc1 的地址？"></a>如何从虚函数表中查找到 vfunc1 的地址？</h3><p>虚函数表中的内容是在编译的时候确定的，通过以下方式进行查找 (* p-&gt;vptr[n] )(p) 或者 (* (p-&gt;vptr)[n] )(p)，它的解读是：通过类对象指针p找到虚指针vptr，再查找到虚函数表中的第n个内容，并将他作为函数指针进行调用，调用时的入参是p(式子中的第二个p)，而这个p就是隐藏的this指针，这里的n也是在编译的时候确定的</p>
<p>作者: JuZi<br>链接: <a href="https://juzihhu.github.io/2022/08/27/cppFoundation/">https://juzihhu.github.io/2022/08/27/cppFoundation/</a><br>来源: JuZi<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="纯虚函数的实现以及意义-为什么析构函数可以是纯虚函数"><a href="#纯虚函数的实现以及意义-为什么析构函数可以是纯虚函数" class="headerlink" title="纯虚函数的实现以及意义 为什么析构函数可以是纯虚函数"></a>纯虚函数的实现以及意义 为什么析构函数可以是纯虚函数</h3><ul>
<li><p>纯虚函数是一个没有实现的虚函数，用 “&#x3D; 0” 表示。它的主要作用是作为基类的接口，让子类强制实现。</p>
</li>
<li><p>纯虚函数的意义是将这个类定义为抽象类，不能实例化对象,从而提供一种标准化的接口，让不同的派生类都能够按照同一种方式来实现它。这样，基类就可以将不同的派生类的实例看作相同的类型，从而提高了程序的可扩展性和可维护性。</p>
</li>
<li><p>析构函数可以是纯虚函数，这是因为当一个基类中含有纯虚析构函数时，说明这个类是个抽象类，不能直接进行实例化。而派生类中必须要实现这个析构函数，因为在派生类中必须要对其进行清理，否则会导致内存泄漏。</p>
</li>
</ul>
<h3 id="什么是虚继承"><a href="#什么是虚继承" class="headerlink" title="什么是虚继承"></a>什么是虚继承</h3><ul>
<li>虚继承解决在多重继承时由于虚基类的复制带来的“菱形继承”问题。虚继承会使派生类只继承一个虚基类的一个实例，从而减少了重复继承</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal eats food&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> numOfLegs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> canFly;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Platypus</span> : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Platypus</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Platypus p;</span><br><span class="line">    p.age = <span class="number">3</span>;</span><br><span class="line">    p.numOfLegs = <span class="number">4</span>;</span><br><span class="line">    p.canFly = <span class="literal">false</span>;</span><br><span class="line">    cout &lt;&lt; p.age &lt;&lt; endl; <span class="comment">//输出 3</span></span><br><span class="line">    p.<span class="built_in">eat</span>(); <span class="comment">//输出 Animal eats food</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++标准库中的 iostream 类就是⼀个虚继承的实际应⽤案例</p>
<p>iostream 从 istream 和 ostream 直接继承⽽来，⽽ istream 和 ostream ⼜都继承⾃⼀个共同的名为 baseios 的类，此时 istream 和 ostream 必须采⽤虚继承，否则将导致 iostream 类中保留两份baseios 类的成员。</p>
<h3 id="shared-ptr线程是否安全？"><a href="#shared-ptr线程是否安全？" class="headerlink" title="shared_ptr线程是否安全？"></a>shared_ptr线程是否安全？</h3><p><code>std::shared_ptr</code> 在单线程环境下是安全的，因为它会自动管理引用计数，确保在没有任何指针指向对象时，正确地删除对象。然而，<code>std::shared_ptr</code> 在多线程环境下需要特别注意，因为引用计数的更新和对象的删除可能涉及多个线程并发访问共享资源。</p>
<h3 id="shared-ptr循环引用怎么解决"><a href="#shared-ptr循环引用怎么解决" class="headerlink" title="shared_ptr循环引用怎么解决"></a>shared_ptr循环引用怎么解决</h3><p>循环引用（Circular Reference）是指多个对象之间形成相互引用的情况，而 <code>shared_ptr</code> 在处理循环引用时可能导致内存泄漏，因为它使用引用计数来管理资源的释放。解决循环引用的常用方法是使用 <code>weak_ptr</code> 来打破循环引用链。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明 B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr; <span class="comment">// A 持有 B 的 shared_ptr</span></span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_weak_ptr; <span class="comment">// B 持有 A 的 weak_ptr</span></span><br><span class="line">    <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立循环引用</span></span><br><span class="line">    a-&gt;b_ptr = b;</span><br><span class="line">    b-&gt;a_weak_ptr = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 a 和 b 的 shared_ptr</span></span><br><span class="line">    a.<span class="built_in">reset</span>();</span><br><span class="line">    b.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于循环引用被打破，A 和 B 正确地释放了资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><strong>shared_ptr</strong></p>
<p>shared_ptr的实现机制是在拷⻉构造时使⽤同⼀份引⽤计数，当一个新的 shared_ptr 对象指向同一资源时，该资源的引用计数增加 1。当某一个对象生命周期结束时，引用计数减 1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line">    T* ptr; <span class="comment">// 指向资源的指针</span></span><br><span class="line">    <span class="type">int</span>* count; <span class="comment">// 引用计数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>() : <span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">count</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) : <span class="built_in">ptr</span>(p), <span class="built_in">count</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; other) : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">count</span>(other.count) &#123; (*count)++; &#125;</span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123; <span class="built_in">dispose</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            (*count)--;</span><br><span class="line">            <span class="keyword">if</span> (*count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            count = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">             <span class="comment">// 释放管理的旧资源</span></span><br><span class="line">            <span class="comment">// 当前对象所指向旧资源引用计数减一</span></span><br><span class="line">            <span class="built_in">dispose</span>();</span><br><span class="line">            <span class="comment">// 当前对象指向新的资源</span></span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            count = other.count;</span><br><span class="line">            (*count)++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (count != <span class="literal">nullptr</span>) ? (*count) : <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;这段代码中的 “operator bool() const” 是一个类型转换函数，用于将 shared_ptr 对象转换为 bool 值。在代码中，它的作用是判断指针指向的资源是否为 nullptr，如果是则返回 false，否则返回 true。&#x3D;&#x3D;</p>
<p>这个转换函数的作用可以体现为：将 shared_ptr 对象看作一个布尔类型的值，如果指针指向的资源存在，则其值为 true，否则其值为 false。这个转换函数的实现方式也比较简洁，只需要判断指针是否为 nullptr 即可。</p>
<p>这样实现的好处是可以方便的在条件语句中使用 shared_ptr 类型的对象，例如在 if 语句中判断一个 shared_ptr 对象是否为空指针，而无需进行显式的比较。</p>
<p>使用方式示例：if (my_shared_ptr) {…} 假如 my_shared_ptr 指向的资源存在，则执行 if 语句中的代码块，否则不执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> a)</span> : age_(a) &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">p2</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码存在的内存泄漏问题是，new出来的对象没有被delete，导致内存泄漏。悬空指针问题是，p2指向的对象已经被p1释放，但是p2仍然指向该对象，从而导致悬空指针问题。解决办法是，使用智能指针来管理内存，可以避免内存泄漏和悬空指针问题</p>
<p><strong>unique_ptr</strong></p>
<p><code>unique_ptr</code>禁止了拷贝构造和赋值构造, 是一种独占指针，它拥有内存，不允许多个指针指向同一份内存。这种指针通常在需要使用动态内存的地方使用。当一个 <code>unique_ptr</code> 被析构时，它拥有的内存也会被释放。</p>
<p><strong>weak_ptr</strong></p>
<p><code>weak_ptr</code>是为了配合shared_ptr引⼊的⼀种智能指针</p>
<p> 可以在不独占资源的情况下监视资源状态的指针，通常用于检查是否还存在对象的共享所有权</p>
<p>假设我们需要实现一个场景，我们需要创建一个 <code>Manager</code> 类来管理一些 <code>Worker</code> 类的对象实例。一个 <code>Manager</code> 可以拥有多个 <code>Worker</code> 实例，每个 <code>Worker</code> 实例必须知道他的 <code>Manager</code> 是谁，但是每个 <code>Worker</code> 实例并不拥有属于 <code>Manager</code> 的所有权。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Worker</span>(std::weak_ptr&lt;Manager&gt; manager, std::string name) : <span class="built_in">manager_</span>(manager), <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::shared_ptr&lt;Manager&gt; manager = manager_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (manager) &#123;</span><br><span class="line">            std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; is working for manager: &quot;</span> &lt;&lt; manager-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; has no manager.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::weak_ptr&lt;Manager&gt; manager_;</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Manager</span>(std::string name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWorker</span><span class="params">(std::shared_ptr&lt;Worker&gt; worker)</span> </span>&#123; workers_.<span class="built_in">push_back</span>(worker); &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;Worker&gt;&gt; workers_;</span><br><span class="line">    std::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Manager&gt; <span class="title">manager</span><span class="params">(<span class="keyword">new</span> Manager(<span class="string">&quot;John&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Worker&gt; <span class="title">worker1</span><span class="params">(<span class="keyword">new</span> Worker(manager, <span class="string">&quot;Alice&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Worker&gt; <span class="title">worker2</span><span class="params">(<span class="keyword">new</span> Worker(manager, <span class="string">&quot;Bob&quot;</span>))</span></span>;</span><br><span class="line">    manager-&gt;<span class="built_in">addWorker</span>(worker1);</span><br><span class="line">    manager-&gt;<span class="built_in">addWorker</span>(worker2);</span><br><span class="line"></span><br><span class="line">    worker1-&gt;<span class="built_in">work</span>(); <span class="comment">// Alice is working for manager: John</span></span><br><span class="line">    worker2-&gt;<span class="built_in">work</span>(); <span class="comment">// Bob is working for manager: John</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// manager销毁后，该manager下的所有worker就成无效的了</span></span><br><span class="line">    manager.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    worker1-&gt;<span class="built_in">work</span>(); <span class="comment">// Alice has no manager.</span></span><br><span class="line">    worker2-&gt;<span class="built_in">work</span>(); <span class="comment">// Bob has no manager.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，当Manager类的智能指针被销毁时，实际上是指该对象所指向的内存空间被释放了，但是Worker类中保存了一个对该Manager对象的shared_ptr引用，引用计数并没有因为对象被销毁而降为0，从而导致了内存泄漏。</p>
<p>具体来说，对于Manager类中的vector容器，它是以shared_ptr的形式存储Worker对象的智能指针的。这意味着，在vector容器使用push_back等操作时，会递增Worker对象的引用计数。因此，在Manager对象被销毁时，Worker对象的引用计数不为0，因为它们仍然在vector容器中以shared_ptr的形式存在，从而导致了内存泄漏。</p>
<p>当使用智能指针时，需要特别注意避免循环引用现象。通过使用weak_ptr等手段，可以避免循环引用导致的内存泄漏问题。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式是一种C++11引入的匿名函数特性，它允许我们在需要函数的地方直接定义一个函数对象，而不必为其创建一个具名函数。lambda表达式的语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123; <span class="comment">// function body&#125;</span></span><br><span class="line">    其中，各部分的含义如下：</span><br><span class="line"></span><br><span class="line">Capture：捕获外部变量，可以省略不写，表示不捕获任何外部变量，或者使用默认捕获方式。</span><br><span class="line"><span class="string">&quot;[]&quot;</span>：表示不捕获任何外部变量；</span><br><span class="line"><span class="string">&quot;[&amp;]&quot;</span>：表示以引用方式捕获所有外部变量；</span><br><span class="line"><span class="string">&quot;[=]&quot;</span>：表示以值传递方式捕获所有外部变量；</span><br><span class="line"><span class="string">&quot;[var1, var2, ...]&quot;</span>：表示以值传递方式捕获指定的外部变量；</span><br><span class="line"><span class="string">&quot;[&amp;var1, &amp;var2, ...]&quot;</span>：表示以引用方式捕获指定的外部变量；</span><br><span class="line"><span class="string">&quot;[=, &amp;var1]&quot;</span>：表示以值传递方式捕获所有外部变量，但是对于var1变量采用引用方式捕获。</span><br><span class="line">Parameters：参数列表，与普通函数的参数列表类似，可以省略不写，表示该函数不接受任何参数。</span><br><span class="line">Return type：返回值类型，可以省略不写，表示该函数没有返回值。</span><br><span class="line">Body：函数体，与普通函数的函数体类似，可以包含一条或多条语句。</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxPathSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y: g[x]) <span class="comment">// 遍历 x 的儿子 y（如果没有儿子就不会进入循环）</span></span><br><span class="line">        maxPathSum = <span class="built_in">max</span>(maxPathSum, <span class="built_in">dfs</span>(y));</span><br><span class="line">    <span class="keyword">return</span> maxPathSum + informTime[x];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [target](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == target;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found target at position &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(vec.<span class="built_in">begin</span>(), it) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Target not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>谓词（Predicate）是一个用于判断某个条件是否成立的函数或者函数对象</p>
<p>lambda表达式<code>[target](int x) -&gt; bool &#123; return x == target; &#125;</code>就是一个谓词。它接受一个int类型的参数x，表示vector中的一个元素，然后返回一个布尔值，表示这个元素是否等于目标值target</p>
<p><strong>当使用引用捕获时，需要注意以下几点：</strong></p>
<ol>
<li>确保在Lambda表达式的有效期内，被捕获的变量仍然有效。避免在Lambda表达式内部使用已经超出作用域的变量引用。</li>
<li>注意捕获变量的生命周期问题。如果被捕获的变量在Lambda表达式执行完毕后会被销毁，那么在Lambda表达式内部就不能持续引用这些变量，否则会引发未定义行为。</li>
<li>当通过引用捕获一个局部变量时，需要确保在捕获列表中使用的变量确实存在，并且在Lambda表达式执行期间没有被销毁。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用引用捕获 x 和 y</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [&amp;x, &amp;y]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">100</span>; <span class="comment">// 修改 x 的值</span></span><br><span class="line">    y = <span class="number">200</span>; <span class="comment">// 修改 y 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">lambda</span>(); <span class="comment">// 输出 x: 100, y: 200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在计算机科学中，闭包（closure）是指一个函数，它包含了它所在作用域中的变量。lambda表达式是一种匿名函数，可以捕获它所在作用域中的变量。因此，lambda表达式可以被认为是闭包。</p>
<p>以下是闭包的几个应用场景：</p>
<ul>
<li>回调函数：闭包可以用来实现回调函数。回调函数是一种在某个事件发生时被调用的函数。</li>
<li>延迟求值：闭包可以用来实现延迟求值。延迟求值是一种在需要时才计算表达式的值的技术。</li>
<li>函数式编程：闭包是函数式编程的基础。函数式编程是一种基于函数的编程范式。</li>
</ul>
<h3 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a><code>auto</code>和<code>decltype</code>的区别</h3><ul>
<li><code>auto</code>是通过编译器计算变量的初始值来推断类型，而<code>decltype</code>同样也是通过编译器来分析表达式进而得到它的类型，但是它不用将表达式的值计算出来。</li>
<li><code>auto</code>将变量的类型和初始值绑定在一起，而<code>decltype</code>将变量的类型和初始值分开；虽然<code>auto</code>的书写更加简洁，但<code>decltype</code>的使用更加灵活。</li>
<li><code>auto</code>可以用于追踪返回类型，可以让编译器自动推导函数返回值的类型；而<code>decltype(auto)</code>可以让编译器自动推导函数返回值的类型，并且可以保留引用类型。</li>
<li><code>auto</code>可以用于迭代器，可以让编译器自动推导迭代器的类型；而<code>decltype</code>可以用于变量声明，可以让编译器自动推导变量的类型。</li>
</ul>
<p>下面是一个代码示例：¹</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="number">10</span>) n2 = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">auto</span> url1 = <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(url1) url2 = <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(n1).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//i</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(n2).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//i</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(url1).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//PKc</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(url2).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//PKc</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存泄漏-amp-悬挂指针（野指针）的危害及避免"><a href="#内存泄漏-amp-悬挂指针（野指针）的危害及避免" class="headerlink" title="内存泄漏&amp;悬挂指针（野指针）的危害及避免"></a>内存泄漏&amp;悬挂指针（野指针）的危害及避免</h3><p>内存泄漏：动态申请的内存空间没有正常释放，但是也不能正确使用的情况；</p>
<ul>
<li><p>程序循环new创建出的对象没有及时delete掉，导致内存泄漏。</p>
</li>
<li><p>delete掉一个void* 类型的指针，导致没有调用到对象的析构函数，析构的所有清理工作都没有去执行从而导致内存的泄漏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span> sz, <span class="type">char</span> c):<span class="built_in">size</span>(sz), <span class="built_in">id</span>(c)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Object() &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; size = &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Object</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Object() &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> []data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object* a = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">10</span>, <span class="string">&#x27;A&#x27;</span>);<span class="comment">//Object*指针指向一个Object对象；</span></span><br><span class="line">    <span class="type">void</span>* b = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">20</span>, <span class="string">&#x27;B&#x27;</span>);<span class="comment">//void*指针指向一个Object对象；</span></span><br><span class="line">    <span class="keyword">delete</span> a;<span class="comment">//执行delete，编译器自动调用析构函数；</span></span><br><span class="line">    <span class="keyword">delete</span> b;<span class="comment">//执行delete，编译器不会调用析构函数，导致data占用内存没有得到回收；</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Press any key to continue... ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>野指针：指向已经删除的对象或者申请访问受限内存区域的指针</p>
<ul>
<li><p>指针变量未初始化：指针变量在被创建未初始化时，并不是空指针，它的缺省值是随机的，会乱指一气。所以指针变量在创建同时就应对其进行初始化，要么将指针设置为NULL，要么让其指向一个合法的内存。</p>
</li>
<li><p>指针释放之后未置空：有时指针在free或者delete之后未赋值NULL，有可能被误以为是合法的指针，不能进关注free和delete后的指针名，他们只是将指针所指向的内存空间释放掉而已，但并没有把指针自身消灭，此时，指针指向的就是“垃圾”内存。被释放掉内存空间的指针应该立即将其置为NULL，防止产生野指针。</p>
</li>
<li><p>指针操作超越变量作用域</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">void</span>)</span></span>&#123; cout &lt;&lt; “Func of <span class="keyword">class</span> <span class="title class_">A</span>” &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A *p;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        A a;</span><br><span class="line">        p = &amp;a; <span class="comment">// 注意 a 的生命期 ，只在这个函数Test中，而不是整个class B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p-&gt;<span class="built_in">Func</span>(); <span class="comment">// p 是“野指针”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  由于a的生命周期只是在void Test(void)函数内部，函数结束时a将被析构，所以在函数外使用指针p指向的内存空间已经被释放了，所以p已经是野指针了</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p><strong>vector底层实际是泛型的动态类型顺序表，因此其底层实际是一段连续的空间</strong>。在SGI-STL的vector中，实际在底层使用三个指针指向该段连续空间的，如下：</p>
<p><strong>start指向空间的起始位置，finish指向最后一个元素的下一个位置，end_of_storage指向空间的末尾</strong>。</p>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//第一种格式用法</span></span><br><span class="line">demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line"><span class="comment">//第二种格式用法</span></span><br><span class="line">demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line"><span class="comment">//第三种格式用法</span></span><br><span class="line">std::array&lt;<span class="type">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line"><span class="comment">//第四种格式用法</span></span><br><span class="line">demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="vector扩容与迭代器失效"><a href="#vector扩容与迭代器失效" class="headerlink" title="vector扩容与迭代器失效"></a><strong>vector扩容与迭代器失效</strong></h3><p>注意结合指针使用时的情况</p>
<p><code>std::vector</code> 可以在中间删除元素。你可以使用 <code>erase</code> 函数来删除指定位置的元素</p>
<p>删除位置索引为2的元素    vec.erase(vec.begin() + 2);</p>
<p>当使用 <code>vector</code> 的 <code>erase</code> 函数删除元素时，会导致迭代器失效，因为删除元素后，容器的大小改变了，原先的迭代器可能会指向无效的位置，从而导致未定义的行为。</p>
<p>为了解决这个问题，可以使用以下方法：使用返回值：<code>erase</code> 函数返回一个指向被删除元素之后元素的迭代器，可以在删除后将迭代器更新为返回的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myVector.<span class="built_in">begin</span>(); it != myVector.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">3</span>) &#123;</span><br><span class="line">        it = myVector.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当向vector中插入元素时，如果元素有效个数size与空间容量capacity相等时，vector内部会触发扩容机制：</p>
<ul>
<li>开辟新空间</li>
<li>拷贝元素</li>
<li>释放旧空间</li>
</ul>
<p><strong>如何避免扩容导致效率低</strong></p>
<p>在插入之前，可以预估vector存储元素的个数，reserve()提前将底层容量开辟好即可。</p>
<p><strong>选择以倍数方式扩容</strong></p>
<p>理想的分配方案是<code>在第N次扩容时如果能复用之前N-1次释放的空间</code>,linux下是按照2倍的方式扩容的，而vs下是按照1.5倍的方式扩容的。</p>
<h3 id="vector扩容，resize和reserve的区别"><a href="#vector扩容，resize和reserve的区别" class="headerlink" title="vector扩容，resize和reserve的区别"></a>vector扩容，resize和reserve的区别</h3><ul>
<li><p><code>resize</code> 方法用于调整 <code>std::vector</code> 中元素的个数，可以增加或减少元素的数量。当使用 <code>resize</code> 增加元素的数量时，新添加的元素会被初始化为默认值（对于基本数据类型，会被初始化为 0）；</p>
<p>如果 <code>resize</code> 减少元素数量，多余的元素会被删除。</p>
</li>
<li><p><code>reserve</code> 方法用于预留 <code>std::vector</code> 的容量，但不改变元素的数量。当使用 <code>reserve</code> 方法预留容量时，<code>std::vector</code> 会分配足够大的内存来容纳指定的元素数量，但并不初始化这些元素。</p>
<p>如果 <code>reserve</code> 分配的容量大于当前容量，会触发扩容，重新分配内存，并将现有元素复制到新的内存空间中。</p>
</li>
</ul>
<h3 id="push-back和emplace-back"><a href="#push-back和emplace-back" class="headerlink" title="push_back和emplace_back"></a>push_back和emplace_back</h3><p>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；</p>
<p>emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程;</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/610294692">https://zhuanlan.zhihu.com/p/610294692</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiaozhong on 2020/9/3.</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2020/9/3 Xiaozhong. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) : _age(age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Construct a person.&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) : _age(p._age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy-Construct&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;&amp;p) <span class="keyword">noexcept</span>: _age(p._age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Move-Construct&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_EMPLACE_BACK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_PUSH_BACK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; person;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">Person</span>(<span class="number">1</span>); <span class="comment">// &gt;: Construct a person.1</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\nemplace_back:\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST_EMPLACE_BACK</span></span><br><span class="line">    person.<span class="built_in">emplace_back</span>(<span class="built_in">move</span>(p)); <span class="comment">// &gt;: Move-Construct1</span></span><br><span class="line">    person.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Construct a person.2  // 构建一个新的元素</span></span><br><span class="line"><span class="comment">     * &gt;: Move-Construct1       // 拷贝之前的元素过来，这个时候用的是 Person(const Person &amp;&amp;p)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;\npush_back\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST_PUSH_BACK</span></span><br><span class="line">    person.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;: Copy-Construct1 因为容器扩容，需要把前面的元素重新添加进来，因此需要拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Construct a person.1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">emplace_back:</span></span><br><span class="line"><span class="comment">Move-Construct1</span></span><br><span class="line"><span class="comment">Construct a person.2</span></span><br><span class="line"><span class="comment">Move-Construct1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">push_back</span></span><br><span class="line"><span class="comment">Construct a person.3</span></span><br><span class="line"><span class="comment">Move-Construct3 //不必要的拷贝和移动 </span></span><br><span class="line"><span class="comment">Move-Construct1</span></span><br><span class="line"><span class="comment">Move-Construct2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a><code>const</code> 成员函数</h3><ul>
<li><code>const</code> 成员函数通过在函数声明后加上 <code>const</code> 关键字来标识。例如：<code>void func() const;</code></li>
<li>在类中，如果一个成员函数不会修改对象的状态，可以将其声明为 <code>const</code> 成员函数。在 <code>const</code> 成员函数中，不能修改任何非 <code>mutable</code> 成员变量。</li>
</ul>
<h3 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h3><p><strong>旧式风格的类型转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(expr); <span class="comment">// 函数形式的强制类型转换</span></span><br><span class="line">(type)expr; <span class="comment">// C语言风格的强制类型转换</span></span><br></pre></td></tr></table></figure>

<p><strong>现代C++风格的类型转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure>

<p>cast-name有static_cast，dynamic_cast，const_cast和reinterpret_cast四种，表示转换的方式。</p>
<p><strong>static_cast</strong></p>
<p>不提供运行时的检查，需要在编写程序时确认转换的安全性。用于进行比较“自然”和低风险的转换,如基本数据类型之间的转换、把void指针转换成目标类型的指针;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j) / i;</span><br><span class="line"><span class="type">void</span> *p = &amp;d;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>

<p><strong>dynamic_cast</strong></p>
<p>dynamic_cast会专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</p>
<ul>
<li><p>其他三种都是编译时完成的，dynamic_cast 是运行时处理的，运行时要进行类型检查</p>
</li>
<li><p>不能用于内置的基本数据类型的强制转换</p>
</li>
<li><p>dynamic_cast 要求 &lt;&gt; 内所描述的目标类型必须为指针或引用。dynamic_cast 转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回 nullptr</p>
</li>
<li><p>在类的转换时，在类层次间进行上行转换（子类指针指向父类指针）时，dynamic_cast 和 static_cast 的效果是一样的</p>
</li>
<li><p>使用 dynamic_cast 进行转换的，<strong>基类中一定要有虚函数</strong>，否则编译不通过</p>
</li>
</ul>
<p><strong>const_cast</strong></p>
<p>const_cast用于移除类型的const、volatile和__unaligned属性</p>
<p><strong>__unaligned修饰的指针或引用允许访问未对齐的内存位置</strong>，默认情况下,C&#x2F;C++要求所有数据的内存地址是其类型大小的整数倍,如果不满足对齐要求则会触发未定义行为。加上__unaligned可以取消这一要求,访问未对齐内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string s = <span class="string">&quot;Inception&quot;</span>;</span><br><span class="line">string&amp; p = <span class="keyword">const_cast</span> &lt;string&amp;&gt; (s);</span><br><span class="line">string* ps = <span class="keyword">const_cast</span> &lt;string*&gt; (&amp;s);  <span class="comment">// &amp;s 的类型是 const string*</span></span><br></pre></td></tr></table></figure>

<p><strong>reinterpret_cast</strong></p>
<p>在编译期完成，可以转换任何类型的指针，所以极不安全；</p>
<h2 id="二、计算机网络"><a href="#二、计算机网络" class="headerlink" title="二、计算机网络"></a>二、计算机网络</h2><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h4><ol>
<li>解析 URL获取 Web 服务器和请求的资源路径，生成发送给 <code>Web</code> 服务器的HTTP请求信息；</li>
<li>DNS域名解析，<strong>查询服务器域名对应的 IP 地址</strong>；（先查本地域名缓存-&gt;本地DNS 服务器）</li>
<li>通过 DNS 获取到 IP 后，应用程序（浏览器）通过调用 Socket 库来委托操作系统中的<strong>协议栈</strong>完成 HTTP 的传输工作；协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作；协议栈的下面一半是用 IP 协议控制网络包收发操作</li>
<li>三次握手建立连接后开始TCP 传输数据；</li>
<li>提供TCP&#x2F;IP四层协议对请求信息进行层层封装，从网卡经过交换机和路由器转发到达服务器，服务器对数据包层层解封，最后解析来自客户端的请求，生成HTTP响应报文再经过层层封装发送到客户端；</li>
</ol>
<p><strong>请问公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？</strong></p>
<p>在发送数据包时，如果目标主机不是本地局域网，填入的 MAC 地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现目标 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。</p>
<p>转发的过程中，源 IP 地址和目标 IP 地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的</p>
<h3 id="HTTP篇"><a href="#HTTP篇" class="headerlink" title="HTTP篇"></a>HTTP篇</h3><h4 id="能否详细解释「HTTP」？"><a href="#能否详细解释「HTTP」？" class="headerlink" title="能否详细解释「HTTP」？"></a>能否详细解释「HTTP」？</h4><p><strong>全称为超文本传输协议，HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</strong></p>
<h4 id="HTTP-常见的状态码有哪些？"><a href="#HTTP-常见的状态码有哪些？" class="headerlink" title="HTTP 常见的状态码有哪些？"></a>HTTP 常见的状态码有哪些？</h4><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，</p>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p>5xx&#96; 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思</li>
</ul>
<h4 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h4><p><em>Host</em> 字段：客户端发送请求时，用来指定服务器的域名。</p>
<p><em>Content-Length 字段</em>：表明本次回应的数据长度</p>
<p><em>Connection 字段</em>：最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用</p>
<p><em>Content-Type 字段</em>用于服务器回应时，告诉客户端，本次数据是什么格式</p>
<p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p>
<p><em>Content-Encoding 字段</em>：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host: www.A.com</span><br><span class="line">Content-Length: 1000</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/html; Charset=utf-8</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>

<h4 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h4><p>从 RFC 规范定义的语义来分析：</p>
<p><strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中；可以理解为「只读」操作</p>
<p><strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同，POST 请求携带数据的位置一般是写在报文 body 中，例如提交留言或者注册就是执行一次post请求；</p>
<h4 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h4><ul>
<li><p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题，HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</p>
</li>
<li><p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</p>
</li>
<li><p>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</p>
</li>
<li><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
<li><p>可以通过哈希算法来保证消息的完整性；</p>
</li>
<li><p>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；</p>
<p>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</p>
</li>
</ul>
<h4 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h4><p> <strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，但是会有中间人攻击的情况发生，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p>
<p>  客户端请求连接可能会有中间人服务器存在的情况。中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p>
<p>  如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p>
<p>  如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p>
<h4 id="HTTP-x2F-1-0、HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3演变"><a href="#HTTP-x2F-1-0、HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3演变" class="headerlink" title="HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变"></a>HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变</h4><ul>
<li><strong>HTTP&#x2F;1.1相比HTTP&#x2F;1.0性能上的改进：</strong></li>
</ul>
<ol>
<li>使用TCP长连接的方式改善了HTTP&#x2F;1.0短连接造成性能开销</li>
<li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</li>
</ol>
<ul>
<li><strong>HTTP&#x2F;1.1 自身的性能瓶颈：</strong></li>
</ul>
<ol>
<li>请求&#x2F;响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩Body的部分</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞</li>
<li>没有请求优先级控制</li>
<li>请求只能从客户端开始，服务器只能被动响应</li>
</ol>
<p>HTTP&#x2F;2协议是基于HTTPS的，所以HTTP&#x2F;2的安全性是有保障的。</p>
<ul>
<li><strong>HTTP&#x2F;2相比HTTP&#x2F;1.1性能上的改进：</strong></li>
</ul>
<ol>
<li><p>HTTP&#x2F;2会压缩头（Header），如果你同时发送多个请求，他们的头是一样的或者是相似的，那么协议会帮你消除重复的部分。</p>
</li>
<li><p>HTTP&#x2F;2不再像HTTP&#x2F;1.1里的纯文本的报文，而是全面采用了二进制格式。头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。</p>
</li>
<li><p>HTTP&#x2F;2的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。客户端还可以指定数据流的优先级。</p>
</li>
<li><p>HTTP&#x2F;2的连接可以并发多个请求（多路复用），而不用按照顺序一一对应。移除了HTTP&#x2F;1.1中的串行请求，不需要排队等待，不会再出现「队头阻塞」问题。</p>
<p>比如：在一个TCP连接里，服务器收到了客户端A和B的两个请求，如果发现A处理过程非常耗时，于是就回应A请求已经处理好的部分，接着回应B请求，完成后，再回应A请求剩下的部分。</p>
</li>
<li><p>服务器推送，HTTP&#x2F;2在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</p>
<p>比如：在浏览器刚请求HTML的时候，就提前把可能用到的JS、CSS文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫Cache Push）</p>
</li>
</ol>
<ul>
<li><strong>HTTP&#x2F;2有哪些缺陷？HTTP&#x2F;3做了哪些优化？</strong></li>
</ul>
<ol>
<li>HTTP&#x2F;2主要的问题在于：多个HTTP请求在复用一个TCP连接，下层的TCP协议是不知道有多少个HTTP请求。所以一旦发生了丢包现象，就会触发TCP的重传机制，这样在一个TCP连接中的所有的HTTP请求都必须等待这个丢了包被重传回来。（区别：HTTP&#x2F;1.1 的管道传输中，如果有一个请求阻塞，那么队列请求也统统被阻塞住了）</li>
<li>HTTP&#x2F;3 把HTTP下层的TCP协议改成了UDP</li>
</ol>
<h4 id="DNS详细说说-DNS用的什么协议"><a href="#DNS详细说说-DNS用的什么协议" class="headerlink" title="DNS详细说说?DNS用的什么协议?"></a>DNS详细说说?DNS用的什么协议?</h4><p><strong>域名解析协议（DNS，Domain Name System），用于将域名和 IP 地址相互映射</strong></p>
<p>DNS使用TCP协议与UDP协议视情况而定，一般来说是认为使用的UDP协议，当客户端向DNS查询域名，一般不会超过512字节，而且无连接的过程更安全也更快；</p>
<p>区域传输时需要使用TCP协议，即进行与主域名服务器进行查询以确认数据是否有效，用TCP则是依赖了其可靠性；</p>
<h4 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h4><p>长连接和短连接都是指客户端和服务器之间的TCP连接的持续时间。</p>
<p>短连接是指客户端与服务器之间的TCP连接只建立一次，数据传输完成后立即关闭连接。每次客户端请求都需要重新建立连接，适用于一些对实时性要求不高的场景，例如HTTP协议中的短连接。</p>
<p>长连接是指客户端与服务器之间的TCP连接可以持续一段时间，不会因为一次数据传输完成就立即关闭连接。适用于需要频繁交互数据的场景，例如在线聊天、视频会议等。在长连接中，客户端和服务器之间可以保持会话状态，减少了重复连接和认证的开销，提高了网络效率。但是，长连接也会占用服务器资源，需要根据实际情况进行权衡和选择</p>
<h4 id="session与cookie的区别"><a href="#session与cookie的区别" class="headerlink" title="session与cookie的区别"></a>session与cookie的区别</h4><p>Session和Cookie是在Web开发中用于维护用户状态和数据的两种机制，但它们有一些区别：</p>
<p><strong>Cookie：</strong></p>
<ol>
<li><strong>存储位置：</strong> Cookie是存储在客户端（浏览器）的小型文本文件中。</li>
<li><strong>大小限制：</strong> Cookie的大小一般受到浏览器的限制，通常为4KB左右。</li>
<li><strong>持久性：</strong> 可以设置Cookie的过期时间，可以是会话级的（浏览器关闭后失效）或持久的（在指定时间后失效）。</li>
<li><strong>跨域：</strong> Cookie可以在同一个域名下的不同页面之间共享，但有域名和路径限制。</li>
<li><strong>安全性：</strong> Cookie的内容可以被用户修改，因此不适合存储敏感信息。</li>
</ol>
<p><strong>Session：</strong></p>
<ol>
<li><strong>存储位置：</strong> Session是存储在服务器端的数据存储区域，通常存储在内存中，也可以存储在数据库或文件中。</li>
<li><strong>大小限制：</strong> 理论上Session的大小不受特定限制，但实际上受服务器资源的限制。</li>
<li><strong>持久性：</strong> Session的生命周期在用户访问网站期间是持久的，但可能会受到服务器的配置和会话管理策略的影响。</li>
<li><strong>跨域：</strong> Session存储在服务器端，因此可以在同一域名下的不同页面之间共享。</li>
<li><strong>安全性：</strong> 相对于Cookie，Session的安全性更高，因为存储在服务器端，用户无法直接访问和修改Session数据。</li>
</ol>
<p><strong>区别总结：</strong></p>
<ul>
<li>Cookie存储在客户端，Session存储在服务器端。</li>
<li>Cookie有大小限制，Session理论上没有固定大小限制。</li>
<li>Cookie可以在客户端持久存储，Session通常在用户关闭浏览器后失效。</li>
<li>Cookie可以跨域共享，Session在同一域名下共享。</li>
<li>Cookie的内容可以被用户修改，Session相对更安全。</li>
</ul>
<h3 id="TCP篇"><a href="#TCP篇" class="headerlink" title="TCP篇"></a>TCP篇</h3><h4 id="什么是-TCP-连接"><a href="#什么是-TCP-连接" class="headerlink" title="什么是 TCP 连接"></a>什么是 TCP 连接</h4><p>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</p>
<h4 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h4><p><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li><p>TCP 是流式传输，没有边界，但保证顺序和可靠。</p>
</li>
<li><p>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</p>
</li>
</ul>
<p><strong>TCP 和 UDP 应用场景：</strong></p>
<p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输；</li>
<li>HTTP &#x2F; HTTPS；</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>
<h4 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h4><p>可以；传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包；传输层的两个传输协议 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<h4 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a>TCP三次握手与四次挥手</h4><p><strong>三次握手：</strong></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
<li>第一次握手：客户端会随机初始化序号（<code>client_isn</code>），同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，之后客户端处于 <code>SYN-SENT</code> 状态；</li>
<li>第二次握手：服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态</li>
<li>第三次握手：客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。</li>
</ul>
<p><strong>原因：</strong></p>
<ul>
<li><p>三次握手才可以阻止重复历史连接的初始化（主要原因）；</p>
<p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，在两次握手的情况下，<strong>服务端在收到 SYN 报文后，就进入ESTABLISHED 状态</strong>，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，<strong>客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接</strong>，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接</p>
</li>
<li><p>三次握手才可以同步双方的初始序列号，如果只有两次握手只保证了一方的初始序列号能被对方成功接收，四次握手是将三次握手的第二次握手拆分为两次，第一次把ACK 置1，同时确认应答号为客户端初始序号+1，第二次把SYN置1，同时初始化自己的序号；</p>
</li>
<li><p>如果没有第三次握手，服务端不清楚客户端是否收到了自己回复的 <code>ACK</code> 报文，所以服务端每收到一个 <code>SYN</code> 就只能先主动建立一个连接<strong>，当客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务端在收到请求后就会</strong>建立多个冗余的无效链接，造成不必要的资源浪费。</p>
</li>
</ul>
<p><strong>四次挥手</strong></p>
<ul>
<li><p>客户端发送FIN请求关闭TCP连接报文，客户端进入 <code>FIN_WAIT_1</code> 状态；</p>
</li>
<li><p>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</p>
</li>
<li><p>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</p>
</li>
<li><p>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</p>
</li>
<li><p>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</p>
</li>
<li><p>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</p>
</li>
<li><p>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</p>
</li>
</ul>
<h4 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h4><p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<h4 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h4><p>发送FIN只是表示关闭了发送数据，在进入CLOSE状态前依然可以接收数据；</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭,优雅关闭TCP连接；</li>
</ul>
<p>客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p>
<p><strong>这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失</strong></p>
<p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。</p>
<p>服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p>
<h4 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h4><p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<h4 id="客户端调用-close-了，连接是断开的流程是什么？"><a href="#客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="客户端调用 close 了，连接是断开的流程是什么？"></a>客户端调用 close 了，连接是断开的流程是什么？</h4><p><img src="%E5%9B%BE%E7%89%87/%E6%A1%8C%E9%9D%A2%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87/format,png-20230309230538308.png"></p>
<ul>
<li>客户端调用 <code>close</code>，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；</li>
<li>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</li>
<li>当处理完数据后，自然就会读到 <code>EOF</code>，于是也调用 <code>close</code> 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；</li>
<li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li>
</ul>
<p>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</p>
<p>客户端经过 <code>2MSL</code> 时间之后，也进入 CLOSE 状态；</p>
<h4 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h4><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，<strong>如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的</strong>，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>：每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<p><strong>TCP 保活的这个机制检测的时间是有点长，可以在应用层实现一个心跳机制:</strong></p>
<p>web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<h4 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h4><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<h4 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h4><ul>
<li><p>超时重传：就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong></p>
</li>
<li><p>快速重传：工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
</li>
<li><p>SACK 方法（Selective Acknowledgment 号选择性确认）：可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
</li>
<li><p>Duplicate SACK：其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong>，能够检测ACK丢包情况、网络延迟情况</p>
</li>
</ul>
<h4 id="TCP粘包是什么？-为什么UDP不粘包？IP-层有粘包问题吗？"><a href="#TCP粘包是什么？-为什么UDP不粘包？IP-层有粘包问题吗？" class="headerlink" title="TCP粘包是什么？ 为什么UDP不粘包？IP 层有粘包问题吗？"></a>TCP粘包是什么？ 为什么UDP不粘包？IP 层有粘包问题吗？</h4><p>应用层传到 TCP 协议的数据，不是以<strong>消息报为单位</strong>向目的主机发送，而是以<strong>字节流</strong>的方式发送到下游，这些数据可能被<strong>切割和组装</strong>成各种数据包，接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。</p>
<p><strong>出现粘包的原因</strong></p>
<p>出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
<p><strong>发送方原因 ：TCP默认使用Nagle算法</strong></p>
<p>Nagle算法主要做两件事：</p>
<ul>
<li>只有上一个分组得到确认，才会发送下一个分组</li>
<li>收集多个小分组，在一个确认到来时一起发送</li>
</ul>
<p><strong>接收方原因</strong></p>
<p>TCP接收到数据包时，并不会马上交到应用层进行处理，会将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p>
<p><strong>如何解决粘包</strong></p>
<p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。一般有三种方式分包的方式：</p>
<ul>
<li><blockquote>
<p>固定长度的消息；即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p>
</blockquote>
</li>
<li><blockquote>
<p>特殊字符作为边界；消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p>
</blockquote>
</li>
<li><blockquote>
<p>自定义消息结构；消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
</blockquote>
</li>
</ul>
<p><strong>UDP不沾包</strong></p>
<p>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。</p>
<p>UDP是面向无连接，不可靠的，基于<strong>数据报</strong>的传输层通信协议，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p><strong>IP 层有粘包问题吗</strong></p>
<p><code>IP 层</code>从按长度切片到把切片组装成一个数据包的过程中，都只管运输，都不需要在意消息的边界和内容，都不在意消息内容了，那就不会有粘包一说了；</p>
<p>数据包也只是按着 TCP 的方式进行组装和拆分，如果数据包有错，那数据包也只是犯了每个数据包都会犯的错而已。</p>
<h4 id="ssh的公钥与私钥的作用"><a href="#ssh的公钥与私钥的作用" class="headerlink" title="ssh的公钥与私钥的作用"></a>ssh的公钥与私钥的作用</h4><p>非对称密钥密码系统，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有<strong>；非对称密钥密码的主要应用就是公钥加密和公钥认证</strong>；</p>
<p><strong>公钥加密</strong></p>
<p>Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下：</p>
<ol>
<li><strong>Bob将他的公开密钥传送给Alice</strong>。</li>
<li><strong>Alice用Bob的公开密钥加密她的消息，然后传送给Bob</strong>。</li>
<li><strong>Bob用他的私人密钥解密Alice的消息</strong>。</li>
</ol>
<p><strong>公钥认证</strong></p>
<p>主要用户鉴别用户的真伪，Alice想让Bob知道自己是真实的Alice，而不是假冒的；</p>
<ol>
<li><strong>Alice用她的私人密钥对文件加密，从而对文件签名</strong>。</li>
<li>Alice将签名的文件传送给Bob。</li>
<li><strong>Bob用Alice的公钥解密文件，从而验证签名</strong>。</li>
</ol>
<p><strong>SSH提供公钥登录</strong></p>
<p>用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录；</p>
<h4 id="怎么判断网络拥塞？"><a href="#怎么判断网络拥塞？" class="headerlink" title="怎么判断网络拥塞？"></a>怎么判断网络拥塞？</h4><p>判断网络拥塞可以通过以下几种方法：</p>
<ol>
<li>延迟增加：当网络出现拥塞时，数据包在传输过程中会遇到更多的延迟。因此，监测数据包的往返时间（Round-Trip Time，RTT）或数据包的传输延迟可以用来判断网络拥塞情况。如果延迟明显增加，可能表示网络发生了拥塞。</li>
<li>丢包率增加：网络拥塞时，路由器或交换机可能丢弃部分数据包，导致数据包丢失。监测数据包的丢失率可以判断网络是否发生拥塞。丢包率的增加通常会导致数据传输的性能下降。</li>
<li>带宽利用率：当网络发生拥塞时，网络带宽可能被完全占用，导致带宽利用率接近100%。监测带宽利用率可以判断网络是否处于拥塞状态。</li>
<li>TCP拥塞窗口：TCP协议中有一个拥塞窗口（Congestion Window），它表示在任意时刻发送方能够发送的最大数据量。在网络拥塞时，TCP拥塞窗口可能会减小，从而限制了数据的传输速率。</li>
<li>流量分析：通过对网络流量进行分析，可以检测是否有大量的数据包在网络中堆积，从而判断是否发生了拥塞。</li>
</ol>
<p>以上方法可以结合使用，以综合判断网络是否发生了拥塞。在实际应用中，可以通过网络监测工具、网络分析工具等来实时监测和诊断网络状态，从而及时发现并解决网络拥塞问题。</p>
<h4 id="如何理解TCP滑动窗口与拥塞控制"><a href="#如何理解TCP滑动窗口与拥塞控制" class="headerlink" title="如何理解TCP滑动窗口与拥塞控制"></a>如何理解TCP滑动窗口与拥塞控制</h4><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><strong>滑动窗口</strong></h5><p><strong>背景</strong>：TCP 是每发送一个数据，都要进行一次确认应答，一问一答的情况下，数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p>
<p>窗口的实现实际上是<code>操作系统开辟的一个缓存空间</code>，发送方主机在等到确认应答返回之前，必须在缓冲区中<code>保留已发送的数据</code>。<strong>如果按期收到确认应答，此时数据就可以从缓存区清除。</strong></p>
<p>窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大</strong></p>
<p><strong>窗口大小由哪一方决定？</strong></p>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由<strong>接收方的窗口</strong>大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<p><img src="https://gitee.com/juzihhu/image_bed/raw/master/img/202308090141680.jpg" alt="img"></p>
<p><strong>接收窗口和发送窗口的大小是相等的吗？</strong></p>
<p>接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>
<p>因为滑动窗口并不是一成不变的。比如，<code>当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。</code>那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个<code>传输过程是存在时延的</code>，所以接收窗口和发送窗口是约等于的关系。</p>
<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p><code>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</code></p>
<p><strong>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</strong></p>
<p>当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，这会<code>导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据</code>，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><p>控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong>当网络拥堵时会发送<strong>数据包时延、丢失等情况，这时 TCP 就会重传数据</strong>，进一步恶性循环加重网络拥堵。</p>
<p><strong>拥塞控制</strong>就是<code>在「发送方」调节所要发送数据的量</code>，<strong>避免「发送方」的数据填满整个网络。</strong></p>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>,发送窗口的值是<code>swnd = min(cwnd, rwnd)，</code>也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li>
</ul>
<h6 id="那么怎么知道当前网络是否出现了拥塞呢？"><a href="#那么怎么知道当前网络是否出现了拥塞呢？" class="headerlink" title="那么怎么知道当前网络是否出现了拥塞呢？"></a><strong>那么怎么知道当前网络是否出现了拥塞呢？</strong></h6><p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<h6 id="拥塞控制有哪些控制算法？"><a href="#拥塞控制有哪些控制算法？" class="headerlink" title="拥塞控制有哪些控制算法？"></a>拥塞控制有哪些控制算法？</h6><p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<p><strong>慢启动算法</strong>：TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量（指数型增长）；</p>
<p><strong>拥塞避免算法</strong>：当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。它的规则是：**每当收到一个 ACK 时，<code>cwnd 增加 1/cwnd（线性增长）</code>;</p>
<p><strong>拥塞发生</strong>:<code>cwnd = cwnd/2 ，也就是设置为原来的一半;慢启动门限ssthresh = cwnd</code>;</p>
<p><strong>快速恢复</strong>:拥塞窗口 <code>cwnd = ssthresh + 3</code> </p>
<h6 id="TCP拥塞控制（Congestion-Control）和流量控制（Flow-Control）"><a href="#TCP拥塞控制（Congestion-Control）和流量控制（Flow-Control）" class="headerlink" title="TCP拥塞控制（Congestion Control）和流量控制（Flow Control）"></a>TCP拥塞控制（Congestion Control）和流量控制（Flow Control）</h6><p>是两个不同但相关的概念，用于管理数据在<strong>计算机网络中的传输</strong>。它们的主要区别在于它们所处理的<code>问题和目标。</code></p>
<ol>
<li><p>TCP拥塞控制（Congestion Control）：</p>
<ul>
<li><p>目标：TCP拥塞控制的主要目标是<strong>确保网络中没有过多的数据包丢失或堵塞，以维持网络的稳定性和性能</strong>。它旨在防止网络拥塞，以确保所有参与通信的设备都能够公平共享网络资源，并在出现拥塞时降低传输速率，以减少数据包丢失。</p>
</li>
<li><p>控制机制：TCP拥塞控制使用一系列算法和技术来检测网络拥塞的迹象，并采取措施来减少发送到网络中的数据量。这包括<strong>慢启动、拥塞避免、拥塞检测等算法</strong>。TCP通过调整发送速率来响应网络拥塞，从而减少拥塞并恢复网络性能。</p>
</li>
<li><p><code>运行范围：TCP拥塞控制是端到端的，它关注的是整个网络路径上的拥塞情况，而不仅仅是两个通信节点之间的数据传输。</code></p>
</li>
</ul>
</li>
<li><p>流量控制（Flow Control）：</p>
<ul>
<li><p>目标：<code>流量控制的主要目标是确保发送方不会以过快的速度向接收方发送数据，以防止接收方无法处理太多数据而导致数据丢失或溢出。</code>流量控制主要关注<strong>通信端点之间的数据流速率匹配</strong>。</p>
</li>
<li><p>控制机制：流量控制通常在数据传输的端点之间进行，涉及发送方和接收方之间的协商。通常使用滑动窗口大小（Window Size）来控制数据的流动速率。接收方通过告知发送方其可接受的数据窗口大小，发送方根据这个窗口大小来限制发送的数据量。</p>
</li>
<li><p>运行范围：流量控制是<strong>端点之间的问题，主要由发送方和接收方之间的协商来控制数据流速率</strong>，而不涉及整个网络路径上的拥塞。</p>
</li>
</ul>
</li>
</ol>
<p>总结来说，TCP拥塞控制关注整个网络路径上的拥塞情况，目标是维护网络的稳定性和性能，而流量控制主要关注通信端点之间的数据流速率匹配，以确保接收方能够处理数据的速率。这两个机制都是为了提高网络性能和可靠性，但它们解决不同层次和类型的问题。</p>
<h4 id="TCP如何保证可靠的连接"><a href="#TCP如何保证可靠的连接" class="headerlink" title="TCP如何保证可靠的连接"></a>TCP如何保证可靠的连接</h4><p>TCP（传输控制协议）通过一系列的机制来保证可靠的连接：</p>
<ol>
<li>确认和重传：TCP使用确认机制，接收方会对收到的数据进行确认应答，如果发送方在合理的时间内未收到确认应答，就会认为数据丢失或损坏，触发数据的重传。这样可以确保数据的可靠传输。</li>
<li>序列号和窗口：TCP通过序列号对数据进行编号，接收方根据序列号将乱序的数据重新组装成正确的顺序。同时，TCP还使用滑动窗口机制来控制发送方发送数据的速率，确保接收方能够及时处理数据。</li>
<li>连接建立和终止：TCP在建立连接时使用三次握手，确保双方都能够正确收发数据。在连接终止时使用四次挥手，确保双方都知道连接已经关闭。</li>
<li>流量控制：TCP使用滑动窗口来控制发送方发送数据的速率，确保接收方能够及时处理数据，避免数据的积压和丢失。</li>
<li>拥塞控制：TCP使用拥塞控制算法来调整发送速率，以避免网络拥塞和数据包丢失。拥塞控制通过动态调整拥塞窗口大小来实现。</li>
<li>超时重传：如果发送方发送的数据在合理的时间内未收到确认应答，就会触发超时重传，重新发送数据，确保数据的可靠传输。</li>
</ol>
<p>通过这些机制，TCP能够在不可靠的IP网络上提供可靠的连接。当网络条件发生变化时，TCP会根据具体情况动态调整自身的行为，以保证数据的可靠传输和连接的稳定性。</p>
<h4 id="UDP连接为什么是不可靠的"><a href="#UDP连接为什么是不可靠的" class="headerlink" title="UDP连接为什么是不可靠的"></a>UDP连接为什么是不可靠的</h4><p>UDP（用户数据报协议）连接是不可靠的，主要有以下几个原因：</p>
<ol>
<li>无连接：UDP是一种面向无连接的协议，发送数据前不需要建立连接，也不需要维护连接状态。因此，没有握手和挥手过程，连接的建立和释放都比较简单。但同时也意味着在传输过程中，不会对数据包进行确认和重传，也不会保证数据包的顺序。</li>
<li>不保证可靠性：UDP不对数据传输的可靠性进行保证。如果在传输过程中发生数据包的丢失、重复、损坏或乱序，UDP不会进行任何处理，而是直接将数据交给上层应用程序处理。这使得UDP传输速度较快，但也导致了不可靠性。</li>
<li>不支持拥塞控制：TCP使用拥塞控制算法来调整发送速率，以避免网络拥塞和数据包丢失。而UDP不支持拥塞控制，发送方会连续发送数据，无论网络的拥塞情况如何，容易导致网络拥塞，进而导致数据丢失。</li>
<li>无法保证顺序：UDP发送的数据包在网络中可能经过不同的路径到达目的地，因此数据包的顺序可能会发生变化。而TCP会对数据包进行排序，保证数据包按顺序传输。</li>
</ol>
<p>因为这些特点，UDP适用于一些对数据传输速度要求较高，但对数据可靠性和顺序要求不高的场景，比如视频直播、实时游戏等。而对于对数据传输的可靠性和顺序要求较高的场景，一般使用TCP连接。</p>
<h4 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h4><ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li>
</ul>
<p><strong>IP 分片</strong>是指在网络通信中，当一个 IP 数据包的大小超过网络传输链路的 MTU（Maximum Transmission Unit），将会被拆分成多个较小的 IP 分片进行传输。</p>
<p>存在隐患：<strong>当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p>
<p>当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」。</p>
<p><strong>因此，尽量避免 IP 分片</strong>，由 IP 层进行分片传输，是非常没有效率的；</p>
<p>为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p>
<p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p>
<h4 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/NUT_Prince/article/details/125918688?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-125918688-blog-111478596.235%5Ev38%5Epc_relevant_sort_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-125918688-blog-111478596.235%5Ev38%5Epc_relevant_sort_base3&utm_relevant_index=8">https://blog.csdn.net/NUT_Prince/article/details/125918688?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-125918688-blog-111478596.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-125918688-blog-111478596.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=8</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38772378">https://zhuanlan.zhihu.com/p/38772378</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/silence_pinot/article/details/111478596">https://blog.csdn.net/silence_pinot/article/details/111478596</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看分支列表： git branch</span><br><span class="line">创建新分支: git branch dev</span><br><span class="line">切换分支 git switch [分支名]  git switch dev</span><br><span class="line">分支的快速创建与切换: git switch -c dev</span><br><span class="line">在 “main” 主分支上运行 git merge [分支名] 命令，将分支的代码合并到主分支: git merge dev</span><br><span class="line">删除 dev 分支,使用 git branch -d [分支名称] </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="TCP-半连接队列和全连接队列？"><a href="#TCP-半连接队列和全连接队列？" class="headerlink" title="TCP 半连接队列和全连接队列？"></a>TCP 半连接队列和全连接队列？</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li><code>半连接队列，也称 SYN 队列；</code></li>
<li><code>全连接队列，也称 accept 队列；</code></li>
</ul>
<p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待<code>进程调用 accept 函数时把连接取出来。</code></strong></p>
<h4 id="如何优化-TCP"><a href="#如何优化-TCP" class="headerlink" title="如何优化 TCP?"></a>如何优化 TCP?</h4><h5 id="三次握手的性能优化"><a href="#三次握手的性能优化" class="headerlink" title="三次握手的性能优化"></a><strong>三次握手的性能优化</strong></h5><ul>
<li><p><strong>客户端优化</strong>：根据网络的稳定性和目标服务器的繁忙程度修改 SYN 的重传次数，调整客户端的三次握手时间上限。比如内网中通讯时，就可以适当调低重试次数，尽快把错误暴露给应用程序。</p>
</li>
<li><p><strong>服务端优化：</strong>Linux 内核会建立一个「半连接队列」来维护「未完成」的握手信息，当半连接队列溢出后，服务端就无法再建立新的连接。</p>
<p><code>服务器收到 ACK 后连接建立成功，此时，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</code></p>
<p><code>如果进程不能及时地调用 accept 函数，就会造成 accept 队列（也称全连接队列）溢出，最终导致建立好的 TCP 连接被丢弃。</code></p>
</li>
<li><p><strong>绕过三次握手</strong>:三次握手建立连接造成的后果就是，HTTP 请求必须在一个 RTT（从客户端到服务器一个往返的时间）后才能发送。</p>
<p><img src="%E5%9B%BE%E7%89%87/%E6%A1%8C%E9%9D%A2%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87/21.jpg" alt="常规 HTTP 请求"></p>
</li>
</ul>
<p>​	在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。</p>
<h5 id="四次挥手的性能优化"><a href="#四次挥手的性能优化" class="headerlink" title="四次挥手的性能优化"></a><strong>四次挥手的性能优化</strong></h5><p>当进程调用了 <code>close</code> 函数关闭连接，此时连接就会是「孤儿连接」，因为它无法再发送和接收数据。</p>
<p>Linux 系统为了防止孤儿连接过多，导致系统资源长时间被占用，就提供了 <code>tcp_max_orphans</code> 参数。如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，而是直接发送 RST 复位报文强制关闭。</p>
<p><img src="%E5%9B%BE%E7%89%87/%E6%A1%8C%E9%9D%A2%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87/39.jpg" alt="四次挥手的优化策略"></p>
<h5 id="数据传输的性能提升"><a href="#数据传输的性能提升" class="headerlink" title="数据传输的性能提升"></a>数据传输的性能提升</h5><p>TCP 连接是由内核维护的，内核会为每个连接建立内存缓冲区：</p>
<p><strong>通过滑动窗口进行流量控制，进而影响传输速度</strong>；</p>
<p>接收方根据它的缓冲区，可以计算出后续能够接收多少字节的报文，这个数字叫做接收窗口。当内核接收到报文时，必须用缓冲区存放它们，这样剩余缓冲区空间变小，接收窗口也就变小了；当进程调用 read 函数后，数据被读入了用户空间，内核缓冲区就被清空，这意味着主机可以接收更多的报文，接收窗口就会变大。</p>
<h4 id="如何理解是-TCP-面向字节流协议？"><a href="#如何理解是-TCP-面向字节流协议？" class="headerlink" title="如何理解是 TCP 面向字节流协议？"></a>如何理解是 TCP 面向字节流协议？</h4><p> <strong>UDP 是面向数据报文的协议</strong></p>
<p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</p>
<p>操作系统在收到 UDP 报文后，会将其插入到队列里，<strong>队列里的每一个元素就是一个 UDP 报文</strong>，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。</p>
<p><strong>TCP 是面向字节流的协议</strong></p>
<p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输，这些消息报文是无保护消息边界的，这样的传输也被看成是流式的传输。</p>
<p><strong>粘包问题</strong></p>
<p>在HTTP请求中，请求头和请求体之间是通过一个空行（\r\n\r\n）来分隔的。因此，在处理HTTP请求时，请求头和请求体之间不会出现粘包问题。服务器会根据请求头中的Content-Length字段或Transfer-Encoding字段来确定请求体的长度，从而正确读取请求体的数据。</p>
<p>粘包问题通常在TCP层面出现，由于TCP是一个字节流协议，因此多个数据包可能会被合并在一起，从而导致粘包现象。但在HTTP层面，由于有请求头和请求体之间的分隔标志，服务器可以正确地识别并处理每个HTTP请求。</p>
<h3 id="已建立连接的TCP，收到SYN会发生什么？"><a href="#已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="已建立连接的TCP，收到SYN会发生什么？"></a>已建立连接的TCP，收到SYN会发生什么？</h3><p>一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 Established 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？</p>
<p><strong>1. 客户端的 SYN 报文里的端口号与历史连接不相同</strong></p>
<p>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</p>
<p>那旧连接里处于 Established 状态的服务端最后会怎么样呢？</p>
<p>如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接。</p>
<p>如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</p>
<p><strong>2. 客户端的 SYN 报文里的端口号与历史连接相同</strong></p>
<p><img src="%E5%9B%BE%E7%89%87/%E6%A1%8C%E9%9D%A2%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87/est_syn.png" alt="img"></p>
<p>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会<code>回复一个携带了正确序列号和确认号的 ACK 报文</code>，这个 ACK 被称之为 Challenge ACK。</p>
<p>接着，<code>客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</code></p>
<h3 id="IP篇"><a href="#IP篇" class="headerlink" title="IP篇"></a>IP篇</h3><h4 id="常见IP相关计算"><a href="#常见IP相关计算" class="headerlink" title="常见IP相关计算"></a>常见IP相关计算</h4><p><strong>网络号</strong>：将IP地址的二进制和子网掩码的二进制进行“&amp;”（and）运算；</p>
<p><strong>广播地址</strong>：将网络号右边的表示IP地址的主机部分的二进制位全部填上1，再将得到的二进制数转换为十进制数就可以得到广播地址；</p>
<p><strong>可用IP地址范围</strong>：因为网络号是172.31.128.0，广播地址是172.31.191.255，所以子网中可用的IP地址范围就是从网络号+1 ~广播地址-1，所以子网中的可用IP地址范围就是从<strong>172.31.128.1-172.31.191.254</strong>。</p>
<p><strong>主机数计算</strong>：2的Y次方-2（Y是子网掩码中0的个数）-2是掐头去尾，头是网络号，尾是广播地址；</p>
<p><strong>子网数目</strong>：2的X次方（X是子网掩码中，借的1的个数）B类掩码默类是用16位，这里的掩码在B类默认掩码的基础上多出了两个表示网络号的1，也就是向主机位借了两个1；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IP地址和子网掩码 172.31.128.255 / 18</span><br><span class="line">ip:        10101100.00011111.10000000.11111111  </span><br><span class="line">子网掩码:　　11111111.11111111.11000000.00000000</span><br><span class="line">网络号:     10101100.00011111.10000000.00000000   &amp;　</span><br><span class="line">网络号点分法表示: 172.31.128.0   </span><br><span class="line">广播地址:    10101100.00011111.10111111.11111111   网络号从右向左0填为1，个数为掩码中的0</span><br><span class="line">广播地址点分法表示: 172.31.191.255</span><br><span class="line">ip地址范围：172.31.128.1-172.31.191.254</span><br><span class="line">子网数目：2^2=4</span><br><span class="line">主机数：2^14-2 = 16382</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IP地址块为<span class="number">211.168</span><span class="number">.15</span><span class="number">.192</span>/<span class="number">26</span>、<span class="number">211.168</span><span class="number">.15</span><span class="number">.160</span>/<span class="number">27</span>和<span class="number">211.168</span><span class="number">.15</span><span class="number">.128</span>/<span class="number">27</span>三个地址块经聚合后可用地址数为（A）</span><br><span class="line">A<span class="number">.126</span> B<span class="number">.62</span> C<span class="number">.128</span> D<span class="number">.68</span></span><br><span class="line"></span><br><span class="line">地址聚合无非是找出它们相同的部分…将两个分配的IP地址块最后一部分换算成二进制(因为只有最后一部分不相同),之后可得出新的子网掩码(子网掩码中相同的部分用<span class="number">1</span>表示,不同的部分用<span class="number">0</span>表示):</span><br><span class="line"><span class="number">211.168</span><span class="number">.15</span>. <span class="number">11000000</span></span><br><span class="line"></span><br><span class="line"><span class="number">211.168</span><span class="number">.15</span>. <span class="number">10100000</span> </span><br><span class="line"></span><br><span class="line"><span class="number">211.168</span><span class="number">.15</span>. <span class="number">10000000</span></span><br><span class="line">可得聚合地址块为<span class="number">211.168</span><span class="number">.15</span>. <span class="number">10000000</span>，即<span class="number">211.168</span><span class="number">.15</span>. <span class="number">128</span></span><br><span class="line">掩码是IP二进制前面相同的位数，由于从 <span class="number">1</span>～<span class="number">25</span>位三个子网完全相同，所以经过聚合后的地址为<span class="number">211.168</span><span class="number">.15</span>. <span class="number">128</span>/<span class="number">25</span>,所以可用地址为：<span class="number">2</span>^(<span class="number">32</span><span class="number">-25</span>)<span class="number">-2</span>=<span class="number">126</span></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果将网络IP段<span class="number">40.15</span><span class="number">.128</span><span class="number">.0</span>/<span class="number">17</span>划分成<span class="number">2</span>个子网,则第一个子网IP段为<span class="number">40.15</span><span class="number">.128</span><span class="number">.0</span>/<span class="number">18</span>,则第二个子网为:(D)</span><br><span class="line"></span><br><span class="line">A<span class="number">.40</span><span class="number">.15</span><span class="number">.129</span><span class="number">.0</span>/<span class="number">18</span> B<span class="number">.40</span><span class="number">.15</span><span class="number">.128</span><span class="number">.128</span>/<span class="number">18</span> C<span class="number">.40</span><span class="number">.15</span><span class="number">.192</span><span class="number">.0</span>/<span class="number">17</span> D<span class="number">.40</span><span class="number">.15</span><span class="number">.192</span><span class="number">.0</span>/<span class="number">18</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span>IP地址<span class="number">32</span>位，分为两段：网络地址＋主机地址。其中可由主机地址分离出一些位来作为子网地址 </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>斜线后的数字是表示用多少位来表示网络地址，这里很明显是<span class="number">17</span>位，那么只有<span class="number">15</span>位表示主机地址 </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>这里分成了两个子网，也就只需要用一位来表示。也就是第<span class="number">18</span>位 </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>第一个地址的第十八位明显是<span class="number">0</span>，第二个只能是<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于IP地址<span class="number">130.63</span><span class="number">.160</span><span class="number">.2</span>，MASK为<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>，子网号为（B）</span><br><span class="line">A<span class="number">.160</span><span class="number">.2</span> B<span class="number">.160</span> C<span class="number">.63</span><span class="number">.160</span> D<span class="number">.130</span><span class="number">.63</span><span class="number">.160</span></span><br><span class="line">    </span><br><span class="line"><span class="number">130.63</span><span class="number">.160</span><span class="number">.2</span>是B类IP地址,B类IP地址前<span class="number">16</span>位（两个字节）为网络号，后<span class="number">16</span>位是主机号,划分子网就是将主机号中的一部分拿出来当做子网号,这里子网掩码为<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>也就是把前三个字节当成了网络号,与B类IP默认的前两个字节作为网络号相比，第三个字节就是子网号，就是<span class="number">160</span>。所以这个ip的网络号是<span class="number">130.63</span> ，子网号是 <span class="number">160</span> ，主机号是<span class="number">2</span></span><br></pre></td></tr></table></figure>





<h2 id="三、操作系统"><a href="#三、操作系统" class="headerlink" title="三、操作系统"></a>三、操作系统</h2><h3 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h3><h4 id="CPU-是如何执行程序的？"><a href="#CPU-是如何执行程序的？" class="headerlink" title="CPU 是如何执行程序的？"></a>CPU 是如何执行程序的？</h4><p><strong>冯诺依曼模型</strong></p>
<p>定义计算机基本结构为 5 个部分，分别是<strong>运算器、控制器、存储器、输入设备、输出设备</strong></p>
<p><strong>线路位宽与 CPU 位宽</strong></p>
<ul>
<li><p>地址总线的位宽度是指 CPU 同时传输地址信息的线路数量。例如，32 位的地址总线具有 32 条传输地址信息的线路，64 位的地址总线具有 64 条传输地址信息的线路。</p>
</li>
<li><p>CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为 <code>2 ^ 32 = 4G</code>。</p>
</li>
</ul>
<p>计算机可以寻址 $2^{32}$ 个不同的内存单元。而每个内存单元的大小是一个字节，这是因为在计算机中，信息被存储在内存中的最小单位就是一个字节。</p>
<p>16GB内存的计算机使用“GB”（GigaByte，即千兆字节）作为单位来表示内存容量大小。16GB表示这台计算机的内存容量是16个GB，即16<em>1024</em>1024*1024字节。</p>
<p>而CPU操作4G大的内存时，需要32条地址总线，是因为4G字节的内存需要32个二进制位（32个比特）来表示内存地址。因此，32条地址总线可以支持寻址$2^{32}$个不同的内存地址，每个地址对应一个字节，从而可以操作4GB大小的内存。</p>
<p>因此，16GB内存的计算机和CPU操作4G大的内存所需要的地址总线数量之间存在一定的联系，但它们是描述内存容量大小的不同方式。可以这样理解：16GB内存的计算机可以容纳比4GB内存的计算机更多的数据，但在CPU访问这些数据时，都需要通过内存地址来定位，而内存地址的位数和地址总线的数量都是限制CPU访问的内存大小的因素。</p>
<p><strong>程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。</strong></p>
<p><strong>64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？</strong></p>
<p><strong>你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？</strong></p>
<ul>
<li>硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是程序指令的位宽</li>
<li>如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是<strong>如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令</strong>；</li>
</ul>
<h4 id="Cache是干什么的-Cache基于什么-为什么要设置多级Cache"><a href="#Cache是干什么的-Cache基于什么-为什么要设置多级Cache" class="headerlink" title="Cache是干什么的?Cache基于什么?为什么要设置多级Cache?"></a>Cache是干什么的?Cache基于什么?为什么要设置多级Cache?</h4><p>Cache是一种高速缓存，用于存储和提供快速访问数据的副本，以加速计算机系统的性能。它位于计算机系统的主存（RAM）和中央处理器（CPU）之间，用于解决CPU访问主存速度较慢的问题。</p>
<p>Cache基于局部性原理，即在程序执行期间，存在较高的数据和指令的重复访问模式。Cache利用这种局部性原理，将最常用的数据和指令存储在更快的存储介质中，以便在需要时能够更快地访问它们。</p>
<p>设置多级Cache是为了更好地利用局部性原理和逐级加速访问的特性。通常，计算机系统会采用多级Cache结构，包括L1、L2、L3等不同级别的Cache。这些级别的Cache之间以及与主存之间有不同的访问速度和容量。</p>
<p>L1 Cache是最接近CPU的缓存，速度最快但容量最小。L2 Cache位于L1 Cache和主存之间，速度较慢但容量较大。L3 Cache是更高级别的缓存，位于L2 Cache和主存之间。<strong>设置多级Cache可以利用不同级别Cache之间的速度和容量差异，以及局部性原理，提供更高效的数据访问，减少CPU访问主存的次数，从而提高计算机系统的整体性能。</strong></p>
<h4 id="如何写出让-CPU-跑得更快的代码？"><a href="#如何写出让-CPU-跑得更快的代码？" class="headerlink" title="如何写出让 CPU 跑得更快的代码？"></a>如何写出让 CPU 跑得更快的代码？</h4><p>要想写出让 CPU 跑得更快的代码，就需要写出缓存命中率高的代码，CPU L1 Cache 分为数据缓存和指令缓存，因而需要分别提高它们的缓存命中率：</p>
<ul>
<li>对于数据缓存，我们在遍历数据的时候，应该按照内存布局的顺序操作，这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二维数组</span><br><span class="line">array[N][N] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//形式一:</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;N; i+=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j+=l) &#123;</span><br><span class="line">        array[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 形式二：</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;N; i+=l) </span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j+=l) &#123;</span><br><span class="line">        arrayljl[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一个操作，循环遍历数组，把小于 <span class="number">50</span> 的数组元素置为 <span class="number">0</span>；</span><br><span class="line">第二个操作，将数组排序；</span><br><span class="line">当数组中的元素是随机的，分支预测就无法有效工作，而当数组元素都是是顺序的，分支预测器会动态地根据历史命中数据对未来进行预测，这样命中率就会很高。</span><br><span class="line"></span><br><span class="line">因此，先排序再遍历速度会更快，这是因为排序之后，数字是从小到大的，那么前几次循环命中 <span class="keyword">if</span> &lt; <span class="number">50</span> 的次数会比较多，于是分支预测就会缓存 <span class="keyword">if</span> 里的 array[i] = <span class="number">0</span> 指令到 Cache 中，后续 CPU 执行该指令就只需要从 Cache 读取就好了。</span><br></pre></td></tr></table></figure>

<p>另外，对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高线程的缓存命中率，可以考虑把线程绑定 CPU 到某一个 CPU 核心</p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ol>
<li>进程是系统资源分配的最小单位，线程是程序执行的最小单位。每个进程都有自己的独立地址空间，而线程共享进程的地址空间。</li>
<li><strong>资源占用：</strong>每个进程都有自己独立的地址空间和系统资源（如文件描述符、网络连接），因此多个进程之间的资源是相互隔离的。而线程共享同一个进程的地址空间和系统资源，因此多个线程可以直接访问共享的数据，但是一个线程崩溃可能导致整个进程崩溃。</li>
<li><strong>通信和同步</strong>：进程通信需要通过IPC机制，如管道、消息队列、信号量等，而线程可以通过共享内存等更简单的方式进行通信。</li>
<li><strong>切换开销：</strong>由于每个进程都有独立的地址空间，进程间切换的开销比较大，需要切换页表和上下文。而线程在同一个进程内，切换开销较小，只需要切换线程的上下文</li>
<li>在多核CPU上，多个线程可以并行执行，从而提高程序的执行效率，而多个进程只能并发执行。</li>
</ol>
<p>多进程适用的场景：</p>
<ul>
<li>需要隔离资源，防止不同任务之间相互干扰或影响。</li>
<li>需要充分利用多核处理器，将计算任务分配给多个独立的进程并行执行。</li>
<li>需要高可靠性，即使一个进程崩溃，其他进程仍然可以继续运行。</li>
</ul>
<p>多线程适用的场景：</p>
<ul>
<li>需要共享数据和共享资源，多个线程可以直接访问相同的数据结构，减少数据传输和拷贝开销。</li>
<li>需要响应性，例如图形界面应用程序需要及时响应用户的操作，使用多线程可以保持界面的流畅性。</li>
<li>需要进行异步编程，处理IO密集型任务时可以通过多线程实现并发处理，提高效率。</li>
</ul>
<p><strong>协程（Coroutine）</strong>是一种轻量级的用户级线程，也被称为协作式多任务处理。与操作系统提供的线程不同，协程的调度和切换不需要进入内核态，而是由用户态的程序自己控制。因此，协程的切换速度非常快，可以避免上下文切换的开销，提高程序的并发能力。</p>
<p>在协程中，程序会在特定的位置暂停，并保留当前状态。下次执行时，程序会从上次暂停的位置继续执行，这个过程中不需要重新加载程序的上下文信息，因此可以实现非常高效的切换。协程通常由程序员自己管理，可以在程序中任意创建和销毁，没有像线程那样的资源消耗。</p>
<p><strong>线程共享的资源：</strong></p>
<ol>
<li><strong>内存空间</strong>：所有线程在同一进程内共享相同的代码段和数据段，这包括程序的指令、全局变量和静态变量等。</li>
<li><strong>文件描述符</strong>：线程共享同一进程的文件描述符表，因此它们可以同时访问同一文件、套接字或其他文件系统资源。</li>
<li><strong>堆内存</strong>：线程可以共享进程的堆内存，这意味着它们可以访问和修改堆中的数据结构和动态分配的内存。</li>
<li><strong>全局变量</strong>：线程可以访问和修改全局变量，但需要注意在多线程环境中对全局变量进行同步以避免竞态条件。</li>
</ol>
<p><strong>线程独有的资源：</strong></p>
<ol>
<li><strong>线程栈</strong>：每个线程都有自己的栈，用于存储局部变量和函数调用信息。线程之间的栈是独立的，因此不会互相干扰。</li>
<li><strong>线程本地存储（Thread-Local Storage，TLS）</strong>：线程可以拥有自己的线程本地存储，其中的数据对其他线程不可见。</li>
<li><strong>线程控制块（Thread Control Block，TCB）</strong>：每个线程都有自己的控制块，用于存储线程的状态信息、寄存器状态、线程标识等。</li>
<li><strong>寄存器集合</strong>：线程拥有自己的寄存器集合，包括程序计数器、栈指针等。这使得线程可以在切换时保留自己的寄存器状态，从而实现线程切换。</li>
</ol>
<h3 id="进程通信的本质"><a href="#进程通信的本质" class="headerlink" title="进程通信的本质"></a>进程通信的本质</h3><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信机制。</p>
<p><strong>管道(pipe)</strong></p>
<p>管道又名匿名管道，这是一种最基本的IPC机制，由pipe函数创建：</p>
<blockquote>
<p>#include &lt;unistd.h&gt;<br>int pipe(int pipefd[2]);</p>
</blockquote>
<p>返回值：成功返回0，失败返回-1；</p>
<p>调用pipe函数时在内核中开辟一块缓冲区用于通信,它有一个读端，一个写端：pipefd[0]指向管道的读端，pipefd[1]指向管道的写端。所以管道在用户程序看起来就像一个打开的文件,通过read(pipefd[0])或者write(pipefd[1])向这个文件读写数据，其实是在读写内核缓冲区。</p>
<p>1.父进程调用pipe开辟管道,得到两个文件描述符指向管道的两端。</p>
<p>2.父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道。</p>
<p>3.父进程关闭管道读端,子进程关闭管道写端。父进程可以往管道里写,子进程可以从管道里读,管道是用环形队列实现的,数据从写端流入从读端流出,这样就实现了进程间通信。</p>
<p>两个进程通过一个管道只能实现单向通信，如果想双向通信必须再重新创建一个管道或者使用sockpair才可以解决这类问题；只能用于具有亲缘关系的进程间通信，例如父子，兄弟进程。</p>
<p><strong>命名管道FIFO</strong></p>
<p>和匿名管道的主要区别在于，命名管道有一个名字，命名管道的名字对应于一个磁盘索引节点，有了这个文件名，任何进程有相应的权限都可以对它进行访问。它允许无亲缘关系进程间的通信；</p>
<p>而匿名管道却不同，进程只能访问自己或祖先创建的管道，而不能访任意访问已经存在的管道——因为没有名字</p>
<p><strong>消息队列（Message Queue）</strong></p>
<p>消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。</p>
<p><strong>共享内存</strong></p>
<p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取操作读出，从而实现了进程间的通信；</p>
<p>采用共享内存进行通信的一个主要好处是<strong>效率高</strong>，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。</p>
<p>在进程间通信的过程中，如果使用管道、消息队列等通信方式，数据需要在内核和用户空间之间进行交换。这个过程需要经过四次数据拷贝：</p>
<ol>
<li>发送进程把数据从用户空间拷贝到内核缓冲区中；</li>
<li>接收进程从内核缓冲区中把数据拷贝到用户空间中；</li>
<li>接收进程把确认信息从用户空间拷贝到内核缓冲区中；</li>
<li>发送进程从内核缓冲区中把确认信息拷贝到用户空间中。</li>
</ol>
<p>共享内存通信方式只需要两次拷贝，是因为它避免了进程间数据的复制，将一块物理内存映射到多个进程的虚拟地址空间，进程之间直接读写这块物理内存即可。因此，共享内存的数据在不同进程间共享，不需要复制到每个进程的地址空间中，减少了数据的拷贝和传输次数，提高了通信效率。共享内存的实现一般需要使用进程间同步的方式来保证共享数据的正确性。</p>
<p>在 Linux 下，可以使用 <code>shmget</code>、<code>shmat</code> 和 <code>shmdt</code> 等系统调用来创建和操作共享内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SHM_SIZE = <span class="number">1024</span>; <span class="comment">// 共享内存大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;s&#x27;</span>); <span class="comment">// 生成共享内存的 key</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存</span></span><br><span class="line">    shmid = <span class="built_in">shmget</span>(key, SHM_SIZE, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;shmget failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接共享内存到当前进程的地址空间</span></span><br><span class="line">    <span class="type">char</span>* shared_memory = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shared_memory == (<span class="type">char</span>*)(<span class="number">-1</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;shmat failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在共享内存中写入数据</span></span><br><span class="line">    std::string message = <span class="string">&quot;Hello from Process 1!&quot;</span>;</span><br><span class="line">    std::<span class="built_in">strcpy</span>(shared_memory, message.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离共享内存</span></span><br><span class="line">    <span class="built_in">shmdt</span>(shared_memory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Fork failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接共享内存到子进程的地址空间</span></span><br><span class="line">        <span class="type">char</span>* shared_memory = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (shared_memory == (<span class="type">char</span>*)(<span class="number">-1</span>)) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;shmat failed in child process.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在共享内存中读取数据</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Message from Process 1: &quot;</span> &lt;&lt; shared_memory &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分离共享内存</span></span><br><span class="line">        <span class="built_in">shmdt</span>(shared_memory);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除共享内存</span></span><br><span class="line">        <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>信号量</strong></p>
<p>它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<p><strong>套接字（Socket）：</strong>套接字是一种网络通信协议，可以实现不同主机之间的进程通信。</p>
<h3 id="线程通信与进程通信的区别"><a href="#线程通信与进程通信的区别" class="headerlink" title="线程通信与进程通信的区别"></a>线程通信与进程通信的区别</h3><p>线程通信和进程通信是两种不同的通信机制，用于实现多个线程或多个进程之间的数据传递和协作。它们之间的主要区别如下：</p>
<ol>
<li>上下文切换开销：<ul>
<li>线程通信：<code>线程属于同一进程，它们共享相同的地址空间</code>，因此在线程之间进行通信时，上下文切换的开销较小。线程之间可以直接访问共享内存，数据的传递和同步比较高效。</li>
<li>进程通信：<code>进程之间拥有独立的地址空间，彼此之间不能直接访问对方的内存。</code>进程通信涉及到<strong>内核态和用户态之间的切换</strong>，因此上下文切换的开销相对较大，通信的性能较低。</li>
</ul>
</li>
<li>同步机制：<ul>
<li>线程通信：线程之间可以使用<strong>互斥锁、条件变量</strong>等同步机制，来保护共享资源的访问，实现线程之间的同步和协作。</li>
<li>进程通信：进程通信涉及到不同进程之间的数据传递，因此需要使用一些特定的通信机制，如<strong>管道、消息队列、共享内存</strong>等，来实现进程之间的同步和数据传递。</li>
</ul>
</li>
</ol>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁（Deadlock）是<code>多个进程或线程因争夺资源而陷入的一种僵局，每个进程都在等待其他进程释放资源，从而导致所有进程都无法继续执行</code>。死锁的形成条件主要有四个：</p>
<ol>
<li><code>互斥条件（Mutual Exclusion）</code>：每个资源最多只能由一个进程或线程占用，其他进程或线程必须等待释放。</li>
<li><code>请求与保持条件（Hold and Wait）</code>：进程在保持自己的资源的同时，还在请求其他进程拥有的资源。</li>
<li><code>不可剥夺条件（No Preemption）</code>：已经分配给一个进程的资源不能被强制性地剥夺，只能由进程自己释放。</li>
<li><code>环路等待条件（Circular Wait）</code>：存在一个进程等待链，每个进程都在等待下一个进程所占用的资源。</li>
</ol>
<p>以下是一些可能产生死锁的场景：</p>
<ol>
<li>多线程资源竞争：多个线程同时访问共享资源，并且在保持自己资源的同时还请求其他线程的资源，形成死锁。</li>
<li>进程间通信：在进程间进行消息传递时，如果进程之间存在相互等待对方消息的情况，可能导致死锁。</li>
<li>交叉锁依赖：多个线程或进程之间按照不同的顺序请求多个锁，导致产生死锁。</li>
</ol>
<p>为了避免死锁，可以采取以下几种策略：</p>
<ol>
<li>破坏死锁条件：破坏死锁产生的四个条件中的任何一个，即可避免死锁。例如，使用资源分配策略确保资源的有序分配，避免环路等待。</li>
<li>使用资源优先级：通过为资源设置优先级，保证资源在请求时按照优先级顺序分配，避免发生死锁。</li>
<li>限制资源的最大持有时间：设置资源的最大持有时间，超过该时间则自动释放资源，避免不可剥夺条件导致的死锁。</li>
<li>死锁检测与恢复：采用死锁检测算法，定期检查系统中是否发生死锁，如果检测到死锁，使用死锁恢复算法解除死锁。</li>
<li>避免长时间持有资源：尽量避免长时间持有资源，减少死锁的发生概率。</li>
<li>协调资源请求顺序：在多线程或多进程中，协调资源请求的顺序，避免交叉锁依赖的情况。</li>
</ol>
<h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p><strong>用户空间与内核空间指的是不同的内存地址空间,<code>用于划分操作系统的运行环境,便于执行不同类型的代码和访问不同的资源。</code></strong></p>
<ol>
<li><strong>用户空间（User Space）：</strong> 用户空间是操作系统给应用程序分配的内存区域，用于运行用户编写的应用程序。用户空间通常位于高内存地址，以防止应用程序错误地访问操作系统核心的内存区域。</li>
<li><strong>内核空间（Kernel Space）：</strong> 内核空间是操作系统核心的运行环境，其中包含了操作系统的各种功能、服务和驱动程序。内核空间通常位于低内存地址，而且是受保护的，应用程序无法直接访问。</li>
</ol>
<p>操作系统使用&#x3D;&#x3D;内核态（Kernel Mode）和用户态（User Mode）&#x3D;&#x3D;来管理内核空间和用户空间的访问权限。在内核态下运行的代码可以访问内核空间，而在用户态下运行的代码只能访问用户空间。当应用程序需要执行操作系统的核心功能（例如进行系统调用）时，会从用户态切换到内核态，操作系统核心会执行相应的操作，然后再切换回用户态。</p>
<p>在现代操作系统中，&#x3D;&#x3D;内核空间和用户空间的划分是为了实现多任务和资源隔离&#x3D;&#x3D;。通过限制用户空间的访问权限，操作系统可以确保应用程序不会直接影响到核心的稳定性和安全性。</p>
<h3 id="数据在内核与用户空间的拷贝问题"><a href="#数据在内核与用户空间的拷贝问题" class="headerlink" title="数据在内核与用户空间的拷贝问题"></a>数据在内核与用户空间的拷贝问题</h3><p>当 Web 服务器处理网络数据时，通常需要将数据从网络套接字读取到内核空间，然后再将数据从内核空间复制到用户空间，以便应用程序进行处理。这两次数据拷贝涉及内核与用户空间之间的数据传输，这可能会导致性能损耗。</p>
<p><strong>iovec 的使用</strong></p>
<p>为了减少数据拷贝带来的性能开销，Linux 提供了 <code>iovec</code> 结构体，&#x3D;&#x3D;用于在用户空间和内核空间之间传递多块非连续的数据&#x3D;&#x3D;。<code>iovec</code> 可以在一次系统调用中读取或写入多个不同位置的数据，从而减少数据在内核和用户空间之间的拷贝次数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> &#123;</span><br><span class="line">    <span class="type">void</span>  *iov_base;    <span class="comment">// 起始地址</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;     <span class="comment">// 数据长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>iovec</code>（I&#x2F;O向量）和<code>readv()</code>函数用于在Socket读取数据时进行高效的数据传输和拷贝;</p>
<p><code>readv()</code>函数是一个系统调用，用于从文件描述符（包括Socket）中读取数据到指定的<code>iovec</code>数组。该函数支持一次读取多个非连续的数据块，从而减少了多次系统调用和数据拷贝的开销。</p>
<p>下面是<code>readv()</code>函数的函数签名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="四、数据库"><a href="#四、数据库" class="headerlink" title="四、数据库"></a>四、数据库</h2><h3 id="数据库连接问题"><a href="#数据库连接问题" class="headerlink" title="数据库连接问题"></a>数据库连接问题</h3><p><strong>自然连接</strong>：是一种很自然的连接，没有指定连接条件，但是连接语句会自动检索两个表R,S的相同名称的列；</p>
<p>如果不是相同名称，则连接退化为笛卡尔积：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">natural</span> <span class="keyword">join</span> works_on</span><br></pre></td></tr></table></figure>

<p><strong>内连接</strong>：当自然连接匹配成功时就是内连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">inner</span> <span class="keyword">join</span> works_on <span class="keyword">on</span> employee.Ssn <span class="operator">=</span> works_on.Essn</span><br></pre></td></tr></table></figure>

<p><strong>外连接</strong>：分为左右外连接与全外连接，但是Mysql并不支持全外连接；</p>
<p>左外连接：</p>
<p>1.左表中的每个元组必须出现在result中</p>
<p>2.如果没有匹配的元组，为右表的属性添加NULL值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> department <span class="keyword">on</span> employee.Ssn <span class="operator">=</span> department.Mgr_ssn</span><br></pre></td></tr></table></figure>

<p>右外连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> department <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> employee <span class="keyword">on</span> employee.Ssn <span class="operator">=</span> department.Mgr_ssn</span><br></pre></td></tr></table></figure>



<h3 id="GROUP-BY的相关使用"><a href="#GROUP-BY的相关使用" class="headerlink" title="GROUP BY的相关使用"></a>GROUP BY的相关使用</h3><p>常用的聚合函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>MAX：返回某列的最大值 </span><br><span class="line"><span class="number">2.</span><span class="built_in">MIN</span>(<span class="keyword">column</span>)	返回某列的最高值 </span><br><span class="line"><span class="number">3.</span><span class="built_in">COUNT</span>(<span class="keyword">column</span>)	返回某列的总行数 </span><br><span class="line"><span class="number">4.</span><span class="built_in">COUNT</span>(<span class="operator">*</span>)	返回表的总行数</span><br><span class="line"><span class="number">5.</span><span class="built_in">SUM</span>(<span class="keyword">column</span>)	返回某列的相加总和</span><br><span class="line"><span class="number">6.</span><span class="built_in">AVG</span>(<span class="keyword">column</span>)	返回某列的平均值</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(sal),<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p><strong>聚合函数只作用非null，因为null数据不参与运算</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(comm),<span class="built_in">avg</span>(ifnull(comm,<span class="number">0</span>)) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p>**GROUP BY **</p>
<p>GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们通常配合 COUNT, SUM, AVG等函数一起使用。</p>
<ul>
<li><p>求部门工资总和</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">sum</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span>  deptno;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询每个部门工资大于1500的的人数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span><span class="number">1500</span> <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>HAVING</strong></p>
<p>HAVING用于分组后的再次筛选,只能用于分组</p>
<ul>
<li><p>求工资总和大于9000的部门,并按照工资总和排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">sum</span>(sal)  total  <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span>  deptno <span class="keyword">having</span> <span class="built_in">sum</span>(sal) <span class="operator">&gt;</span><span class="number">9000</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(sal) <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>having和where区别：</strong></p>
<p><code>HAVING</code>允许我们在聚合后的结果中进行条件过滤，而<code>WHERE</code>则适用于对非聚合列的条件过滤。</p>
<p>请注意，使用<code>HAVING</code>的前提是进行了<code>GROUP BY</code>分组，因为<code>HAVING</code>是用于<strong>对聚合后的分组结果进行过滤</strong>。如果没有进行<code>GROUP BY</code>，那么使用<code>WHERE</code>子句是更合适的选项。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">having</span>是分组后，<span class="keyword">where</span>是分组前</span><br><span class="line"><span class="number">2.</span><span class="keyword">where</span>不用使用聚合函数，<span class="keyword">having</span>可以使用聚合函数。</span><br><span class="line"><span class="number">3.</span><span class="keyword">where</span>在分组之前就会进行筛选，过滤掉的数据不会进入分组</span><br></pre></td></tr></table></figure>

<p>关键字的书写顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">select</span> </span><br><span class="line"><span class="number">2.</span><span class="keyword">from</span></span><br><span class="line"><span class="number">3.</span><span class="keyword">where</span></span><br><span class="line"><span class="number">4.</span><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="number">5.</span><span class="keyword">having</span></span><br><span class="line"><span class="number">6.</span><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="number">7.</span> limit</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">sum</span>(sal)  total  <span class="keyword">from</span> emp <span class="keyword">where</span> sal<span class="operator">&gt;</span><span class="number">1000</span> <span class="keyword">group</span> <span class="keyword">by</span>  deptno <span class="keyword">having</span> <span class="built_in">sum</span>(sal) <span class="operator">&gt;</span><span class="number">9000</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(sal) <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p>SQL查询的目的是从<code>emp</code>表中选择满足薪资大于1000的员工记录，然后按照部门对薪资进行分组，并计算每个部门的总薪资。最后，只有当某个部门的总薪资超过9000时，该部门的记录才会包含在结果中，并按照总薪资的升序进行排序。</p>
<p><strong>参考链接：</strong></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3Mjk2NDc3Ng==&mid=2247483790&idx=1&sn=a3e69709dd27eff171d8754babe88026&chksm=fcc9ab49cbbe225f55492bcbbc6ac12fe2734c4a3ac06801e1e72d536b481a6ac90d10155e6f&scene=27">https://mp.weixin.qq.com/s?__biz=MzU3Mjk2NDc3Ng==&amp;mid=2247483790&amp;idx=1&amp;sn=a3e69709dd27eff171d8754babe88026&amp;chksm=fcc9ab49cbbe225f55492bcbbc6ac12fe2734c4a3ac06801e1e72d536b481a6ac90d10155e6f&amp;scene=27</a></p>
<p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong></p>
<h3 id="SQL-查询语句执行过程"><a href="#SQL-查询语句执行过程" class="headerlink" title="SQL 查询语句执行过程"></a>SQL 查询语句执行过程</h3><ul>
<li>连接器：经过 TCP 三次握手建立连接（MySQL 是基于 TCP 协议进行传输），管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p>
<ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
</ul>
<p>什么是<code>聚簇索引？ </code>找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。 什么是非聚簇索引？ 索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。</p>
<p><strong>所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法；InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎；</strong></p>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）</li>
</ul>
<p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O（把读取一个节点当作一次磁盘 I&#x2F;O 操作），所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</strong></p>
<h4 id="树形存储与磁盘IO关系"><a href="#树形存储与磁盘IO关系" class="headerlink" title="树形存储与磁盘IO关系"></a>树形存储与磁盘IO关系</h4><p><strong>磁盘IO时间 &#x3D; 寻道 + 磁盘旋转 + 数据传输时间</strong></p>
<p>从磁盘读取数据时，系统会将逻辑地址发给磁盘，磁盘将逻辑地址转换为物理地址（哪个磁道，哪个扇区）。 <code>磁头进行机械运动，先找到相应磁道，再找该磁道的对应扇区</code>，扇区是磁盘的最小存储单元。</p>
<p>(寻道时间) 首先接收到要读取的数据的物理位置, 传动臂将读写头定位到数据对应的磁道, 一般这个寻道的时间单位为 ms.</p>
<p>(旋转时间) 定位到对应磁道上后, 接着等待读写头定位到该磁道上数据对应的扇区的第一个字节.</p>
<p>(传输时间) 从磁盘读出或者写入数据, 通常这个时间是最低的.</p>
<p><img src="https://gitee.com/juzihhu/image_bed/raw/master/img/202308012301860.png"></p>
<p><strong>索引在磁盘上的存储</strong></p>
<p>每个InnoDB表都有一个称为聚集索引的特殊索引，该索引是按照表的主键构造的一棵B+树。</p>
<p>根据示例数据构建如图所示聚簇索引；</p>
<p><img src="https://gitee.com/juzihhu/image_bed/raw/master/img/202308012303570.png" alt="image-20230801230353955"></p>
<ul>
<li><code>叶子节点存放了整张表的所有行数据。</code></li>
<li>非叶子节点并不存储行数据，是为了能<code>存储更多索引键</code>，从而降低B+树的高度，进而减少IO次数。</li>
<li>聚集索引的存储在物理上并不是连续的，每个数据页在不同的磁盘块，通过一个双向链表来进行连接</li>
</ul>
<p>&#x3D;&#x3D;查找：假设要查找数据项6&#x3D;&#x3D;</p>
<ol>
<li>把根节点由磁盘块0加载到内存，发生一次IO，在内存中用二分查找确定6在3和9之间；</li>
<li>通过指针P2的磁盘地址，将磁盘2加载到内存，发生第二次IO，再在内存中进行二分查找找到6，结束。</li>
</ol>
<p>这里只进行了两次IO，实际上，每个磁盘块大小为4K，3层的B+树可以表示上百万的数据，也就是每次查找只需要3次IO，所以索引对性能的提高将是巨大的。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903856388718606">https://juejin.cn/post/6844903856388718606</a></p>
<h4 id="主键索引的-B-Tree-和二级索引的-B-Tree-区别"><a href="#主键索引的-B-Tree-和二级索引的-B-Tree-区别" class="headerlink" title="主键索引的 B+Tree 和二级索引的 B+Tree 区别"></a>主键索引的 B+Tree 和二级索引的 B+Tree 区别</h4><ul>
<li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li>
<li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p><strong>回表：</strong>先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。<strong>这个过程要查两个 B+Tree 才能查到数据</strong>；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>覆盖索引</strong>：查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到结果，这时就不用再查主键索引；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？"><a href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？" class="headerlink" title="为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？"></a>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</h4><p><em><strong>1、B+Tree vs B Tree</strong></em></p>
<p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下（特定大小的内存缓冲区，B+树可以将更多的节点加载到内存中），能查询更多的数据。</p>
<p><strong>从而在相同数量的磁盘I&#x2F;O操作下，提供更高的查询吞吐量和性能。这使得B+树在处理大规模数据和频繁查询的场景下非常有效。</strong></p>
<p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p>
<p>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</p>
<p><em><strong>2、B+Tree vs Hash</strong></em></p>
<p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p>
<p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p>
<h4 id="索引按字段特性分类"><a href="#索引按字段特性分类" class="headerlink" title="索引按字段特性分类"></a>索引按字段特性分类</h4><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p>
<p><strong>主键索引</strong>：建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值；</p>
<p><strong>唯一索引</strong>：建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值；</p>
<p>在创建表时，创建唯一索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>建表后，如果要创建唯一索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure>

<p><strong>普通索引</strong>：建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE；</p>
<p><strong>前缀索引</strong>：对字符类型字段的<strong>前几个字符建立的索引</strong>，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p>
<p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p>
<h3 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a>事务篇</h3><h4 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><ul>
<li>原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态；</li>
<li>一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。（比如转账前后总金额不变）</li>
<li>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，&#x3D;&#x3D;因为多个事务同时使用相同的数据时，不会相互干扰&#x3D;&#x3D;，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</li>
<li>持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p><strong>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</strong></p>
<p>持久性是通过 redo log （重做日志）来保证的；<br>原子性是通过 undo log（回滚日志） 来保证的；<br>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；<br>一致性则是通过持久性+原子性+隔离性来保证；</p>
<h4 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h4><p>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。</p>
<p>脏读（dirty read）：一个事务「读到」了另一个「未提交事务修改过的数据」</p>
<p>不可重复读（non-repeatable read）：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</p>
<p>幻读（phantom read）：在一个事务内多次查询某个符合查询条件的「记录数量」，&#x3D;&#x3D;如果出现前后两次查询到的记录数量不一样的情况&#x3D;&#x3D;，就意味着发生了「幻读」现象。</p>
<h4 id="事务隔离级别是怎么实现的？"><a href="#事务隔离级别是怎么实现的？" class="headerlink" title="事务隔离级别是怎么实现的？"></a>事务隔离级别是怎么实现的？</h4><p>SQL 标准提出了四种隔离级别来规避以上三种现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p>
<ul>
<li>读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li>读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li>可重复读（repeatable read），指一个事务执行过程中看到的数据，<strong>一直跟这个事务启动时看到的数据是一致的</strong>，&#x3D;&#x3D;MySQL InnoDB 引擎的默认隔离级别&#x3D;&#x3D;；</li>
<li>串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<p>这四种隔离级别具体是如何实现的呢？</p>
<p>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了； 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问； 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，&#x3D;&#x3D;Read View 可以理解成一个数据快照&#x3D;&#x3D;，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。</p>
<h4 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h4><p>MVCC（多版本并发控制）：通过「版本链」来控制并发事务访问同一个记录时的行为；用于「读提交」和「可重复读」隔离级别的实现</p>
<h4 id="MySQL-有哪些锁？"><a href="#MySQL-有哪些锁？" class="headerlink" title="MySQL 有哪些锁？"></a>MySQL 有哪些锁？</h4><h2 id="五、算法与数据结构"><a href="#五、算法与数据结构" class="headerlink" title="五、算法与数据结构"></a>五、算法与数据结构</h2><h3 id="背包总结"><a href="#背包总结" class="headerlink" title="背包总结"></a>背包总结</h3><p>解题思路：<br>1.确定dp的含义<br>2.递推公式<br>3.初始化<br>4.确定遍历顺序</p>
<p>01背包问题</p>
<p> dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。<br> dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);<br>&#x2F;&#x2F;初始化 dpvector&lt;vector<int>&gt; dp(weight.size(), vector<int>(bagweight + 1, 0));<br>for(intj &#x3D; weight[0]; j &lt;&#x3D; bagweight; j++) {<br>    dp[0][j] &#x3D; value[0];<br>}</int></int></p>
<p>滚动数组</p>
<p>dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>遍历顺序需要注意<br>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次</p>
<p>分割等和子集 -&gt; 背包问题<br>目标和（求方案数）<br>1和0</p>
<p>注意求最值与求方案数的区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(S) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br><span class="line">        <span class="keyword">if</span> ((S + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br><span class="line">        <span class="type">int</span> bagSize = (S + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagSize + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = bagSize; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完全背包问题</p>
<p>物品无限，可以重复加入；<br>无需再考虑内层循环从大到小遍历的情况；<br>对于求最值问题：无需考虑双重循环的顺序<br>对于求方案数量问题：考虑求排列数量（先遍历容量）还是求组合数量（先遍历物品）<br>零钱兑换求最少硬币数（最值问题），求方案数量（排列数问题，先遍历物品）</p>
<p>多重背包理论</p>
<p>有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大<br>每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了</p>
<p>打家劫舍1，2，3<br>树形dp的实现思路</p>
<p>状态dp</p>
<p>买卖股票的最佳时机1，2，3，4</p>
<h3 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>关键思路：辅助栈思想 <code>stack&lt;int&gt; x_stack;    stack&lt;int&gt; min_stack;</code>min_stack栈顶元素记录 x_stack对应当前状态的最小元素，可以保证O(1)时间复杂度；</p>
<h3 id="HDU-ACM-1446-计算直线的交点数"><a href="#HDU-ACM-1446-计算直线的交点数" class="headerlink" title="HDU ACM:1446 计算直线的交点数"></a>HDU ACM:1446 计算直线的交点数</h3><p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1466">http://acm.hdu.edu.cn/showproblem.php?pid=1466</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Description</span><br><span class="line">平面上有n条直线，且无三线共点，问这些直线能有多少种不同交点数。 </span><br><span class="line">比如,如果n=<span class="number">2</span>,则可能的交点数量为<span class="number">0</span>(平行)或者<span class="number">1</span>(不平行)。</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">输入数据包含多个测试实例,每个测试实例占一行,每行包含一个正整数n（n&lt;=<span class="number">20</span>）,n表示直线的数量.</span><br><span class="line">Output</span><br><span class="line">每个测试实例对应一行输出，从小到大列出所有相交方案，其中每个数为可能的交点数,每行的整数之间用一个空格隔开。</span><br><span class="line">Sample Input</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Sample Output</span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>四条直线全部平行，无交点</span><br><span class="line"><span class="number">2.</span>其中三条平行，交点数: (n<span class="number">-1</span>)*<span class="number">1</span> +<span class="number">0</span>=<span class="number">3</span></span><br><span class="line"><span class="number">3.</span>其中两条平行，而另外两条直线的交点既可能平行也可能相交，因此交点数据分别为：  (n<span class="number">-2</span>)*<span class="number">2</span>+<span class="number">0</span>=<span class="number">4</span>，(n<span class="number">-2</span>)*<span class="number">2</span>+<span class="number">1</span>=<span class="number">5</span></span><br><span class="line"><span class="number">4.</span> 四条直线互不平行， 交点数为(n<span class="number">-3</span>)*<span class="number">3</span>+<span class="number">3</span>条直线的相交情况：    (n<span class="number">-3</span>)*<span class="number">3</span>+<span class="number">0</span>=<span class="number">3</span> ，(n<span class="number">-3</span>)*<span class="number">3</span>+<span class="number">2</span>=<span class="number">5</span> ，(n<span class="number">-3</span>)*<span class="number">3</span>+<span class="number">3</span>=<span class="number">6</span></span><br><span class="line"> M条直线的交点方案数 = r 条直线交叉的交点数与(m-r)条平行线 + r 条直线本身的交点方案 = (m - r) * r + r 条直线之间的交点数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n条直线的最多可能交点数为n*(n-1)/2，即前n个自然数的和。</span><br><span class="line">20条直线最多有190个交点。用一个二维数组DP[21][200]，数组中只保存0、1，用来表示该下标对应的可能交点数是否有效。</span><br><span class="line">例如：DP[3][2]=1，表示总数N为3条直线的情况下，2个交点的情况有效</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> DP[<span class="number">21</span>][<span class="number">200</span>];</span><br><span class="line">    <span class="type">int</span> N,n,<span class="built_in">free</span>,j;</span><br><span class="line">    <span class="built_in">memset</span>(DP,<span class="number">0</span>,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;<span class="number">21</span>;n++)</span><br><span class="line">    &#123;</span><br><span class="line">        DP[n][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;<span class="number">21</span>;n++)                               <span class="comment">//直线总数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">free</span>=<span class="number">0</span>;<span class="built_in">free</span>&lt;n;<span class="built_in">free</span>++)                   <span class="comment">//自由直线总数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n*(n<span class="number">-1</span>)/<span class="number">2</span>;j++)            <span class="comment">//可能的交点数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(DP[<span class="built_in">free</span>][j]==<span class="number">1</span>)              <span class="comment">//若free条自由直线有j个交点的可能性为真</span></span><br><span class="line">                &#123;</span><br><span class="line">                    DP[n][<span class="built_in">free</span>*(n-<span class="built_in">free</span>)+j]=<span class="number">1</span>;   <span class="comment">//那么n条直线在free条自由直线，n-free条平行直线的情况下</span></span><br><span class="line">                                                <span class="comment">//的free*(n-free)+j个交点的可能性为真</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i,top=N*(N<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=top;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="comment">//为HDU ACM格式化输出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(DP[N][i]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="约瑟夫环——公式法（递推公式）"><a href="#约瑟夫环——公式法（递推公式）" class="headerlink" title="约瑟夫环——公式法（递推公式）"></a>约瑟夫环——公式法（递推公式）</h3><p><code> f(N,M)=(f(N−1,M)+M)%N</code></p>
<p><code>f(N,M)</code>表示，N个人报数，每报到M时杀掉那个人，最终胜利者下标（故其编号为<code>f(N,M)+1</code>）</p>
<p>如果不删除数组元素，可以使用一个bool类型的数组来标记每个人是否已经被排除。修改后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">josephus</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">-1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=m; i++) &#123;</span><br><span class="line">            cur=(cur+<span class="number">1</span>)%n;</span><br><span class="line">            <span class="keyword">while</span> (used[cur]) &#123;</span><br><span class="line">                cur=(cur+<span class="number">1</span>)%n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[cnt]=cur+<span class="number">1</span>;</span><br><span class="line">        used[cur] = <span class="literal">true</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">josephus</span>(n, m);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The elimination order is: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意不能返回局部对象的引用或者指针；</p>
<h3 id="血量问题"><a href="#血量问题" class="headerlink" title="血量问题"></a>血量问题</h3><p>血量为n,k个技能对应的伤害为1到k,技能可以无限重复使用,有多少种方案杀死 </p>
<p>完全背包问题：求排列数，先遍历血量再遍历物品</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i] 表示血量为 i 的怪物被杀死的方案数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 初始状态，血量为 0 的怪物已经被杀死</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 枚举每个血量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j &lt;= i; j++) &#123;  <span class="comment">// 枚举使用技能造成的伤害</span></span><br><span class="line">            dp[i] = (dp[i] + dp[i - j]) % MOD;  <span class="comment">// 转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释如下：</p>
<ul>
<li>首先，我们定义状态 dp[i] 表示血量为 i 的怪物被杀死的方案数。</li>
<li>初始状态：当怪物血量为 0 时，它已经被杀死了，所以 dp[0] &#x3D; 1。</li>
<li>状态转移：对于血量为 i 的怪物，它可以通过使用任意一种技能造成 1 到 k 点的伤害，因此我们枚举技能造成的伤害 j，并累加 dp[i-j] 到 dp[i] 上。状态转移方程为：dp[i] &#x3D; sum{dp[i-j]} (1 &lt;&#x3D; j &lt;&#x3D; k &amp;&amp; j &lt;&#x3D; i)。</li>
<li>最终答案：当怪物的血量为 n 时，它被杀死的方案数为 dp[n]。</li>
</ul>
<h3 id="牛顿迭代法求平方根代码实现"><a href="#牛顿迭代法求平方根代码实现" class="headerlink" title="牛顿迭代法求平方根代码实现"></a>牛顿迭代法求平方根代码实现</h3><p>要求是这样：输入一个数，输出其对应的平方根。假设输入的数是 m，则其实是求一个 x 值<br>$$<br>使其满足 x^2 &#x3D; m，令f(x) &#x3D; x^2 - m ，<br>$$<br>其实就是求方程 f(x) &#x3D; 0 的根那么 f(x) 的导函数是 f’(x) &#x3D; 2x。那么 f(x) 函数的曲线在<br>$$<br>(xn，xn^2 - m)<br>$$<br>处的切线的斜率是：2xn，因此切线方程是：<br>$$<br>y &#x3D; 2xn (x - xn) + xn^2 - m<br>$$<br>故切线与x轴的交点是：xn+1 &#x3D; (xn + m &#x2F; xn ) &#x2F; 2<br>根据牛顿迭代法，首先应该在曲线 f(x) 上任意选取一点，做切线。那么，我们直接把输入的数 m，作为选取的点的横坐标，即 x0 &#x3D; m，然后根据上式进行迭代。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// err 是允许的误差</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> err = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">NtSqrt</span><span class="params">(<span class="type">const</span> <span class="type">double</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">double</span> root = num;</span><br><span class="line">        <span class="comment">// 如果原值减去近似根的平方大于误差，继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">abs</span>(num - root * root) &gt;= err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 得到下一个近似根</span></span><br><span class="line">            root = (num / root + root) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LRU缓存算法"><a href="#LRU缓存算法" class="headerlink" title="LRU缓存算法"></a>LRU缓存算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现双向链表结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkedNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> key,value;</span><br><span class="line">    DLinkedNode* pre,*next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>():<span class="built_in">key</span>(<span class="number">0</span>),<span class="built_in">value</span>(<span class="number">0</span>),<span class="built_in">pre</span>(<span class="literal">nullptr</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="type">int</span> k,<span class="type">int</span> y):<span class="built_in">key</span>(k),<span class="built_in">value</span>(y),<span class="built_in">pre</span>(<span class="literal">nullptr</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,DLinkedNode*&gt; mapCache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity=capacity;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点和尾节点</span></span><br><span class="line">        head=<span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail= <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next=tail;</span><br><span class="line">        tail-&gt;pre=head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span></span>&#123;</span><br><span class="line">        node-&gt;pre=head;</span><br><span class="line">        node-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;pre=node;</span><br><span class="line">        head-&gt;next=node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span></span>&#123;</span><br><span class="line">        node-&gt;pre-&gt;next=node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre=node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span></span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;pre;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapCache.<span class="built_in">find</span>(key)==mapCache.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        DLinkedNode* node=mapCache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapCache.<span class="built_in">find</span>(key)==mapCache.<span class="built_in">end</span>())&#123;</span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key,value);</span><br><span class="line">            mapCache[key]=node;</span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span>(size&gt;capacity)&#123;</span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                mapCache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            DLinkedNode* node=mapCache[key];</span><br><span class="line">            node-&gt;value=value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="快排；稳定版本快排；三路快排；"><a href="#快排；稳定版本快排；三路快排；" class="headerlink" title="快排；稳定版本快排；三路快排；"></a>快排；稳定版本快排；三路快排；</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pivot</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>; <span class="comment">// 普通快速排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pivot_stable</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>; <span class="comment">// 稳定的快速排序</span></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pivot_three</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>; <span class="comment">// 三路归并</span></span><br><span class="line"><span class="function">v</span></span><br><span class="line"><span class="function">    oid <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// int piv = pivot(nums, left, right);</span></span><br><span class="line">    <span class="comment">// int piv = pivot_stable(nums, left, right);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// quickSort(nums, left, piv - 1);</span></span><br><span class="line">    <span class="comment">// quickSort(nums, piv + 1, right);</span></span><br><span class="line">    std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; piv = <span class="built_in">pivot_three</span>(nums, left, right);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, left, piv.first - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, piv.second + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pivot</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = nums[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt; p)</span><br><span class="line">            --right;</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= p)</span><br><span class="line">            ++left;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = p;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pivot_stable</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec_p</span><span class="params">(right - left + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> piv = nums[left];</span><br><span class="line">    <span class="type">int</span> vec_lf = <span class="number">0</span>, local = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; piv)</span><br><span class="line">            vec_p[vec_lf++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    local = vec_lf;</span><br><span class="line">    vec_p[vec_lf++] = piv;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= piv)</span><br><span class="line">            vec_p[vec_lf++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vec_lf = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (local == vec_lf) &#123;</span><br><span class="line">            res = i;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = vec_p[vec_lf++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">pivot_three</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> piv = nums[left];</span><br><span class="line">    <span class="type">int</span> cur = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] &lt; piv) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(nums[cur++], nums[left++]); <span class="comment">// cur++</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[cur] &gt; piv) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(nums[cur], nums[right--]); <span class="comment">// cur right--</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; left, right &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNums</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="built_in">heapSort</span>(arr, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printNums</span>(arr, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list1) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(!list2) <span class="keyword">return</span> list1;</span><br><span class="line">        ListNode* phead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>),*cur;</span><br><span class="line">        phead-&gt;next=list1;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&gt;list2-&gt;val)&#123;</span><br><span class="line">            phead-&gt;next=list2;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(flag) list1=list1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> list2=list2-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(list1&amp;&amp;list2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next=list1;</span><br><span class="line">                list1=list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next=list2;</span><br><span class="line">                list2=list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1) cur-&gt;next=list1;</span><br><span class="line">        <span class="keyword">else</span> cur-&gt;next=list2;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并k个有序链表</h3><h3 id="给定一棵二叉树和target，输出路径之和-x3D-target的路径"><a href="#给定一棵二叉树和target，输出路径之和-x3D-target的路径" class="headerlink" title="给定一棵二叉树和target，输出路径之和&#x3D;target的路径"></a>给定一棵二叉树和target，输出路径之和&#x3D;target的路径</h3><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;result) result=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="最长无重复子串"><a href="#最长无重复子串" class="headerlink" title="最长无重复子串"></a>最长无重复子串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> max_len=<span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; map;</span><br><span class="line">        map.<span class="built_in">insert</span>(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>,len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="type">char</span> t=s[i];</span><br><span class="line">            <span class="keyword">if</span>(!map.<span class="built_in">count</span>(t)) map.<span class="built_in">insert</span>(t);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(map.<span class="built_in">count</span>(t))&#123;</span><br><span class="line">                    map.<span class="built_in">erase</span>(s[start]);</span><br><span class="line">                    ++start;</span><br><span class="line">                &#125;</span><br><span class="line">                map.<span class="built_in">insert</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">            len=i-start+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;res) res=len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>题目描述：给定两个字符串，求出他们之间最长相同子字符串长度。<br>解题步骤：采用动态规划，与求解最长公共子序列类似，只不过状态定义要修改。<br>1、 状态定义：dp[i][j]表示以s1[i]和s2[j]为最后一个元素的最长公共子串，如果最长公共子串存在，公共子串的最后一个元素一定是s1[i]或者s2[j]他们相等。<br>2、 状态转移方程：<br>如果s1[i]和s2[j]相等，那么：dp[i][j] &#x3D; dp[i-1][j-1]+1；<br>如果s1[i]和s2[j]不相等，则：dp[i][j] &#x3D; 0；<br>3、 初始化：初始dp[0][j]和dp[i][0]都为0<br>4、 输出：dp[i][j]的最大值<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zy450271923/article/details/105301611">https://blog.csdn.net/zy450271923/article/details/105301611</a></p>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义dp数组和lcs数组，大小分别是(text1.size()+1)×(text2.size()+1)，并初始化为0和空字符串</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; <span class="built_in">lcs</span>(text1.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;string&gt;(text2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划求解最长公共子序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=text1.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=text2.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="comment">// 如果text1[i-1]和text2[j-1]相等，则它们可以作为公共子序列的一部分</span></span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;  <span class="comment">// 更新dp[i][j]的值为dp[i-1][j-1]+1</span></span><br><span class="line">                    lcs[i][j]=lcs[i<span class="number">-1</span>][j<span class="number">-1</span>]+text1[i<span class="number">-1</span>];  <span class="comment">// 更新lcs[i][j]的值为lcs[i-1][j-1]+text1[i-1]</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果text1[i-1]和text2[j-1]不相等，则它们不能同时作为公共子序列的一部分</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);  <span class="comment">// dp[i][j]的值由dp[i-1][j]和dp[i][j-1]中的较大值决定</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j]==dp[i<span class="number">-1</span>][j]) lcs[i][j]=lcs[i<span class="number">-1</span>][j];  <span class="comment">// 如果dp[i][j]由dp[i-1][j]转移而来，则lcs[i][j]也由lcs[i-1][j]转移而来</span></span><br><span class="line">                    <span class="keyword">else</span> lcs[i][j]=lcs[i][j<span class="number">-1</span>];  <span class="comment">// 否则，lcs[i][j]由lcs[i][j-1]转移而来</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;lcs[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()]&lt;&lt;endl;  <span class="comment">// 输出最长公共子序列</span></span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];  <span class="comment">// 返回text1和text2的最长公共子序列长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=word1.<span class="built_in">size</span>(),m=word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;++i) dp[<span class="number">0</span>][i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i) dp[i][<span class="number">0</span>]=i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="type">int</span> temp =<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i<span class="number">-1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                    temp=<span class="built_in">min</span>(temp,dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>); </span><br><span class="line">                    dp[i][j]=temp;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>题目</strong><br>字符串A编辑成字符串B可有三种操作： 插入、删除、修改，对应的代价为c0，c1，c2，给出字符串A和字符串B以及各自长度m、n，返回字符串A编辑成字符串B的最小代价。</p>
<p><strong>分析</strong><br>状态dp[i][j]表示A[0,…i-1]编辑为B[0,…j-1]需要的代价，i，j指的是当前A、B中的字符个数</p>
<p>边界值讨论<br>i &#x3D; 0时，表示从空串编辑为B[0,…j-1],需要插入j个元素，dp[0][j] &#x3D; c0*j</p>
<p>j &#x3D; 0时，表示从A[0,..i-1]编辑为空串，需要删除i个元素，dp[i][0] &#x3D; c1* i;</p>
<p>一般情况讨论<br>其他情况中A[0,…i-1]编辑为B[0,…j-1]，有以下两种情况：</p>
<p>（一）A[i-1] &#x3D;&#x3D; B[j-1]时，最后一个元素不用动，只用考虑A[0,…i-2]编辑为B[0,…j-2]需要的代价,dp[i][j] &#x3D; dp[i-1][j-1]</p>
<p>（二）A[i-1]!&#x3D;B[j-1]时，又可以分成以下三种情况：</p>
<p>1、从A[0,…i-2]编辑为B[0,…j-1]，再删除A[i-1]</p>
<p>2、从A[0,…i-1]编辑为B[0,…j-2]，再插入B[j-1]</p>
<p>3、从A[0,…i-2]编辑为B[0,…j-2]，再将A[i-1]修改为B[j-1]</p>
<p>在以上三种情况中取最小值。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gulaixiangjuejue/article/details/85249973">https://blog.csdn.net/gulaixiangjuejue/article/details/85249973</a></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>饿汉模式： 在类加载时就创建了实例</strong></p>
<p>实例对象 <code>instance</code> 被定义为 <code>static</code> 局部变量，而且是在静态成员函数 <code>getInstance()</code> 内部进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sigleton_E</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Sigleton_E</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sigleton_E&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Sigleton_E&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Sigleton_E instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sigleton_E is doing something.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Sigleton_E <span class="keyword">operator</span>=(<span class="type">const</span> Sigleton_E&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Sigleton_E</span>(<span class="type">const</span> Sigleton_E&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sigleton_E Sigleton_E::instance;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sigleton_E&amp; instance1 = Sigleton_E::<span class="built_in">getInstance</span>();</span><br><span class="line">    Sigleton_E&amp; instance2 = Sigleton_E::<span class="built_in">getInstance</span>();</span><br><span class="line">    instance1.<span class="built_in">doSomething</span>();</span><br><span class="line">    instance2.<span class="built_in">doSomething</span>();</span><br><span class="line">    instance1 = instance2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;instance1:&quot;</span> &lt;&lt; &amp;instance1 &lt;&lt; <span class="string">&quot;  instance2:&quot;</span> &lt;&lt; &amp;instance2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sigleton_E</span></span><br><span class="line"><span class="comment">Sigleton_E is doing something.</span></span><br><span class="line"><span class="comment">Sigleton_E is doing something.</span></span><br><span class="line"><span class="comment">instance1:0xd81700  instance2:0xd81700</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>懒汉模式： 单例实例在第一次使用时才会被创建，线程不安全，需要加入互斥锁保证线程安全；</strong></p>
<p><strong>懒汉模式</strong>中的 <code>static Singleton* instance</code> 并不会在类加载时创建。它只是一个&#x3D;&#x3D;指针&#x3D;&#x3D;，它的初始值为 <code>nullptr</code>，表示还没有创建实际的单例实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton is doing something.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton* instance1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* instance2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    instance1-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    instance2-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instance1 == instance2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Both instances are the same.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Instances are different.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;instance1:&quot;</span> &lt;&lt; instance1 &lt;&lt; <span class="string">&quot;  instance2:&quot;</span> &lt;&lt; instance2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h3><h4 id="内存限制下查找数组的重复数"><a href="#内存限制下查找数组的重复数" class="headerlink" title="内存限制下查找数组的重复数"></a>内存限制下查找数组的重复数</h4><p>&#x3D;&#x3D;哈希&#x3D;&#x3D;，<code>如果数据量很大，采用位方式（俗称位图）存储数据是常用的思路</code></p>
<ul>
<li>题目要求：给定一个数组，包含从1到N的整数，N最大为32000，数组可能还有重复值，且N的取值不定，若只有4KB的内存可用，该如何打印数组中所有重复元素。</li>
</ul>
<blockquote>
<p>如果只有4KB的空间，那么只能寻址8<em>4</em>2^10个比特，这个值比32000要大的，因此我们可以创建32000比特的位向量(比特数组)，其中一个比特位置就代表一个整数。</p>
<p>利用这个位向量，就可以遍历访问整个数组。如果发现数组元素是v，那么就将位置为v的设置为1，碰到重复元素，就输出一下。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Bitmap 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化位图的大小</span></span><br><span class="line">    <span class="built_in">Bitmap</span>(<span class="type">int</span> size = <span class="number">32</span>) &#123;</span><br><span class="line">        bits = <span class="keyword">new</span> <span class="type">int</span>[size / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，释放内存</span></span><br><span class="line">    ~<span class="built_in">Bitmap</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] bits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询给定位置的位是否为 1</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123; <span class="comment">// true if bit is 1, else: false</span></span><br><span class="line">        <span class="keyword">return</span> (bits[pos / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (pos &amp; <span class="number">0x1f</span>))) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置给定位置的位为 1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        bits[pos / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (pos &amp; <span class="number">0x1f</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *bits; <span class="comment">// 存储位图的数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组中的重复元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_duplicates</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> bitsize)</span> </span>&#123;</span><br><span class="line">    <span class="function">Bitmap <span class="title">bm</span><span class="params">(bitsize)</span></span>; <span class="comment">// 创建一个位图实例</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bm.<span class="built_in">get</span>(a[i] - <span class="number">1</span>)) <span class="comment">// 查询位图中是否已经设置了该位置</span></span><br><span class="line">            cout &lt;&lt; a[i] &lt;&lt; endl; <span class="comment">// 如果已经设置，则说明该元素是重复的，打印出来</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bm.<span class="built_in">set</span>(a[i] - <span class="number">1</span>); <span class="comment">// 如果没有设置，则设置该位置为 1，表示该元素已经出现过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">32000</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">32000</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">8</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print_duplicates</span>(a, <span class="number">20</span>, <span class="number">32000</span>); <span class="comment">// 调用函数打印出重复的元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当 <code>pos</code> 的值为 35 时，我们来看一下 <code>get</code> 和 <code>set</code> 函数是如何处理的。</p>
<ol>
<li><code>get</code> 函数：</li>
</ol>
<ul>
<li><code>pos / 32</code> 计算出 <code>pos</code> 对应的 <code>bits</code> 数组的索引：35 &#x2F; 32 &#x3D; 1，所以我们需要查看 <code>bits[1]</code>。</li>
<li><code>pos &amp; 0x1f</code> 计算出 <code>pos</code> 对应的 <code>bits</code> 数组索引内的位偏移：35 &amp; 0x1f &#x3D; 3，所以我们需要查看 <code>bits[1]</code> 的第 3 位。</li>
<li><code>1 &lt;&lt; (pos &amp; 0x1f)</code> 生成一个只有第 3 位为 1 的值，即 00001000（二进制）。</li>
<li><code>bits[pos / 32] &amp; (1 &lt;&lt; (pos &amp; 0x1f))</code> 操作将 <code>bits[1]</code> 中的第 3 位与上述生成的值进行位与操作。如果结果非 0，那么表示该位置已经被设置为 1。如果结果为 0，表示该位置没有被设置为 1。</li>
</ul>
<ol>
<li><code>set</code> 函数：</li>
</ol>
<ul>
<li><code>pos / 32</code> 计算出 <code>pos</code> 对应的 <code>bits</code> 数组的索引：35 &#x2F; 32 &#x3D; 1，所以我们需要设置 <code>bits[1]</code>。</li>
<li><code>pos &amp; 0x1f</code> 计算出 <code>pos</code> 对应的 <code>bits</code> 数组索引内的位偏移：35 &amp; 0x1f &#x3D; 3，所以我们需要设置 <code>bits[1]</code> 的第 3 位。</li>
<li><code>1 &lt;&lt; (pos &amp; 0x1f)</code> 生成一个只有第 3 位为 1 的值，即 00001000（二进制）。</li>
<li><code>bits[pos / 32] |= (1 &lt;&lt; (pos &amp; 0x1f))</code> 操作将 <code>bits[1]</code> 中的第 3 位与上述生成的值进行位或操作，将该位置的位设置为 1。</li>
</ul>
<p>综上所述，在这个例子中，当 <code>pos</code> 为 35 时，<code>get</code> 函数会返回 <code>false</code>，因为 <code>bits[1]</code> 的第 3 位是 0，表示这个位置没有被设置为 1。而调用 <code>set</code> 函数后，<code>bits[1]</code> 的第 3 位会被设置为 1。</p>
<ul>
<li>题目要求：给定一个输入文件，包含40亿个非负整数，请设计一个算法，产生一个不存在该文件中的整数，假设你有1GB的内存来完成这项任务。</li>
</ul>
<p>假设用哈希表来保存出现过的数，如果 40 亿个数都不同，则哈希表的记录数为 40 亿条，存一个 32 位整数需要 4B，<code>所以最差情况下需要 40 亿*4B=160 亿字节，大约需要16GB 的空间</code>，这是不符合要求的。</p>
<p>如果数据量很大，<code>采用位方式（俗称位图）存储数据是常用的思路</code>，那位图如何存储元素的呢？ 我们可以使用 bit map 的方式来表示数出现的情况。具体地说， 是<code>申请一个长度为 4 294 967 295 的 bit 类型的数组 bitArr（就是boolean类型），bitArr 上的每个位置只可以表示 0 或1 状态</code>。8 个bit 为 1B，所以长度为 4 294 967 295 的 bit 类型的数组占用 <strong>500MB</strong> 空间，这就满足题目给定的要求了。</p>
<p>那怎么使用这个 bitArr 数组呢？就是遍历这 40 亿个无符号数，遇到所有的数时，就把 bitArr 相应位置的值设置为 1。例如，遇到 1000，就把bitArr[7000]设置为 1。</p>
<p>遍历完成后，再依次遍历 bitArr，看看哪个位置上的值没被设置为 1，这个数就不在 40 亿个数中。例如，发现 bitArr[8001]&#x3D;&#x3D;0，那么 8001 就是没出现过的数，遍历完 bitArr 之后，所有没出现的数就都找出来了。</p>
<p><strong>位存储的核心是：我们存储的并不是这40亿个数据本身，而是其对应的位置。</strong></p>
<p><strong>使用10MB来存储</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">如果现在只有 <span class="number">10</span>MB 的内存，此时位图也不能搞定了，我们要另寻他法。这里我们使用分块思想，时间换空间，通过两次遍历来搞定。</span><br><span class="line"></span><br><span class="line">如果只有<span class="number">10</span>MB，我们只要求找到其中一个没出现过的数即可。</span><br><span class="line"></span><br><span class="line">首先，将<span class="number">0</span>~<span class="number">4</span> <span class="number">294</span> <span class="number">967</span> <span class="number">295</span>(<span class="number">2</span>^<span class="number">32</span>) 这个范围是可以平均分成 <span class="number">64</span> 个区间的，每个区间是 <span class="number">67</span> <span class="number">108</span> <span class="number">864</span> 个数，例如：</span><br><span class="line"></span><br><span class="line">第<span class="number">0</span> 区间（<span class="number">0</span>~<span class="number">67</span> <span class="number">108</span> <span class="number">863</span>）</span><br><span class="line"></span><br><span class="line">第 <span class="number">1</span> 区间（<span class="number">67</span> <span class="number">108</span> <span class="number">864</span>~<span class="number">134</span> <span class="number">217</span> <span class="number">728</span>）</span><br><span class="line"></span><br><span class="line">第 <span class="selector-tag">i</span> 区间（<span class="number">67</span> <span class="number">108</span> <span class="number">864</span>´<span class="selector-tag">I</span>~<span class="number">67</span> <span class="number">108</span> <span class="number">864</span>´(<span class="selector-tag">i</span>+<span class="number">1</span>)-<span class="number">1</span>），</span><br><span class="line"></span><br><span class="line">……，</span><br><span class="line"></span><br><span class="line">第 <span class="number">63</span> 区间（<span class="number">4</span> <span class="number">227</span> <span class="number">858</span> <span class="number">432</span>~<span class="number">4</span> <span class="number">294</span> <span class="number">967</span> <span class="number">295</span>）。</span><br><span class="line"></span><br><span class="line">因为一共只有 <span class="number">40</span> 亿个数，所以，如果统计落在每一个区间上的数有多少，肯定有至少一个区间上的计数少于<span class="number">67</span> <span class="number">108</span> <span class="number">864</span>。利用这一点可以找出其中一个没出现过的数。具体过程是通过两次遍历来搞定：</span><br><span class="line"></span><br><span class="line">第一次遍历，先申请长度为 <span class="number">64</span> 的整型数组 countArr<span class="selector-attr">[0..63]</span>，countArr<span class="selector-attr">[i]</span>用来统计区间 <span class="selector-tag">i</span> 上的数有多少。遍历 <span class="number">40</span> 亿个数，根据当前数是多少来决定哪一个区间上的计数增加。例如，如果当前数是 <span class="number">3</span> <span class="number">422</span> <span class="number">552</span> <span class="number">090</span> ， <span class="number">3</span> <span class="number">422</span> <span class="number">552</span> <span class="number">090</span>/<span class="number">67</span> <span class="number">108</span> <span class="number">864</span>=<span class="number">51</span> ， 所以第 <span class="number">51</span> 区间上的计数增加countArr<span class="selector-attr">[51]</span>++。遍历完 <span class="number">40</span> 亿个数之后，遍历 countArr，必然会有某一个位置上的值（countArr<span class="selector-attr">[i]</span>） 小于 <span class="number">67</span> <span class="number">108</span> <span class="number">864</span>，表示第 <span class="selector-tag">i</span> 区间上至少有一个数没出现过。我们肯定会找到至少一个这样的区间。</span><br><span class="line"></span><br><span class="line">此时使用的内存就是countArr 的大小（<span class="number">64</span>*<span class="number">4</span>B），是非常小的。</span><br><span class="line"></span><br><span class="line">假设找到第 <span class="number">37</span> 区间上的计数小于 <span class="number">67</span> <span class="number">108</span> <span class="number">864</span>，那么我们对这<span class="number">40</span>亿个数据进行第二次遍历：</span><br><span class="line"></span><br><span class="line">申请长度为 <span class="number">67</span> <span class="number">108</span> <span class="number">864</span> 的 bit map，这占用大约 <span class="number">8</span>MB 的空间，记为 bitArr<span class="selector-attr">[0..67108863]</span>。</span><br><span class="line"></span><br><span class="line">遍历这 <span class="number">40</span> 亿个数，此时的遍历只关注落在第 <span class="number">37</span> 区间上的数，记为 num（num满足num/<span class="number">67</span> <span class="number">108</span> <span class="number">864</span>==<span class="number">37</span>），其他区间的数全部忽略。</span><br><span class="line"></span><br><span class="line">如果步骤 <span class="number">2</span> 的 num 在第 <span class="number">37</span> 区间上，将 bitArr<span class="selector-attr">[num - 67108864*37]</span>的值设置为 <span class="number">1</span>，也就是只做第 <span class="number">37</span> 区间上的数的 bitArr 映射。</span><br><span class="line"></span><br><span class="line">遍历完 <span class="number">40</span> 亿个数之后，在 bitArr 上必然存在没被设置成 <span class="number">1</span> 的位置，假设第 <span class="selector-tag">i</span> 个位置上的值没设置成 <span class="number">1</span>，那么 <span class="number">67</span> <span class="number">108</span> <span class="number">864</span>´<span class="number">37</span>+<span class="selector-tag">i</span> 这个数就是一个没出现过的数。</span><br></pre></td></tr></table></figure>

<p>总结一下进阶的解法：</p>
<p>根据 10MB 的内存限制，确定统计区间的大小，就是第二次遍历时的 bitArr 大小。</p>
<p>利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。</p>
<p>对这个区间上的数做 bit map 映射，再遍历bit map，找到一个没出现的数即可。</p>
<ul>
<li>题目要求：有一个包含 20 亿个全是 32 位整数的大文件，在其中找到出现次数最多的数。要求，内存限制为 2GB。</li>
</ul>
<p>一共有 20 亿个数，哪怕只是一个数出现了 20 亿次，用 32 位的整数也可以表示其出现的次数而不会产生溢出，所以哈希表的 key 需要占用 4B，value 也是 4B。那么哈希表的一条记录（key,value）需要占用 8B，当<code>哈希表记录数为 2 亿个时，需要至少 1.6GB 的内存</code>。</p>
<p>如果 20 亿个数中不同的数超过 2 亿种，最极端的情况是 20 亿个数都不同，那么在哈希表中可能需要产生 20 亿条记录，这样内存会不够用，所以一次性用哈希表统计 20 亿个数的办法是有很大风险的。</p>
<p>解决办法是<code>把包含 20 亿个数的大文件用哈希函数分成 16 个小文件</code>，根据哈希函数的性质，&#x3D;&#x3D;同一种数不可能被散列到不同的小文件上&#x3D;&#x3D;，同时每个小文件中不同的数一定不会大于 2 亿种， 假设哈希函数足够优秀。<strong>然后对每一个小文件用哈希表来统计其中每种数出现的次数，这样我们就得到了 16 个小文件中各自出现次数最多的数</strong>，还有各自的次数统计。接下来只要选出这16 个小文件各自的第一名中谁出现的次数最多即可。</p>
<h2 id="六、项目"><a href="#六、项目" class="headerlink" title="六、项目"></a>六、项目</h2><h3 id="子宫动脉栓塞仿真"><a href="#子宫动脉栓塞仿真" class="headerlink" title="子宫动脉栓塞仿真"></a>子宫动脉栓塞仿真</h3><h4 id="Unet、Res-Unet-原理与区别"><a href="#Unet、Res-Unet-原理与区别" class="headerlink" title="Unet、Res_Unet 原理与区别"></a><strong>Unet、Res_Unet 原理与区别</strong></h4><p>UNET主要由编码器和解码器两个部分组成。编码器通过多次的卷积和池化操作来提取图像的特征信息，得到一个高维度的特征图。解码器则通过反卷积和上采样等操作将编码器输出的特征图还原为与输入图像相同大小的分割结果;</p>
<p>Res_Unet是在Unet的基础上增加了残差连接。残差连接是一种特殊的跳跃连接方式，可以将网络的层数增加到很深。残差连接可以直接将输入特征图加到输出特征图上，使得网络可以学习到残差信息，从而提高网络性能。</p>
<h4 id="Marching-Cubes算法和拉普拉斯网格优化算法"><a href="#Marching-Cubes算法和拉普拉斯网格优化算法" class="headerlink" title="Marching Cubes算法和拉普拉斯网格优化算法"></a><strong>Marching Cubes算法和拉普拉斯网格优化算法</strong></h4><p>Marching Cubes算法是一种用于从三维数据中提取等值面的方法，用于将三维数据（如医学图像）转换为三维表面网格表示;</p>
<p>基本思想是将三维数据集分成许多小的三维单元格，并根据每个单元格中数据的值来确定表面的位置和形状。具体而言，Marching Cubes算法将每个单元格分成8个小单元格，并使用每个小单元格的数据值（例如，体素密度）来确定表面的位置和形状。根据每个小单元格中数据值的组合，Marching Cubes算法确定表面的形状，例如球形、柱状、平面或其他复杂形状。最后，通过将所有单元格的表面连接在一起，生成一个完整的三维表面网格表示。</p>
<p>Marching Cubes算法的优点是可以处理不规则的、非均匀的、非线性的三维数据，生成高质量、准确的表面网格表示。它还可以在可接受的时间内处理大规模数据集。然而，Marching Cubes算法也存在一些缺点，例如可能产生表面拓扑错误、边界不完整或重叠的表面片段等问题;</p>
<p>拉普拉斯网格优化算法是一种用于三维模型的平滑算法，它的目的是将模型中不平滑的部分进行平滑，以得到更加自然的曲面。项目中利用了拉普拉斯矩阵，对模型进行网格优化。通过计算每个顶点的平均值来调整其位置，对于一个给定的顶点，它的平均值是指所有相邻顶点的位置之和再除以相邻顶点数。使用拉普拉斯方程的离散形式将平均值加权到原始位置上得到新的位置；</p>
<h4 id="unity粒子系统"><a href="#unity粒子系统" class="headerlink" title="unity粒子系统"></a><strong>unity粒子系统</strong></h4><p>Unity的粒子系统是一个强大的工具，可以用来创建各种流体效果。它的实现原理主要是基于GPU的粒子渲染技术，具体来说，它会通过发射器不断地生成粒子，并根据每个粒子的属性和发射器的控制来更新粒子的状态。然后，所有的粒子会被传递给GPU进行计算和渲染，最终生成不同的特效效果；</p>
<h3 id="webserver"><a href="#webserver" class="headerlink" title="webserver"></a>webserver</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>TinyWebServer主要的目的是实现一个轻量级的HTTP服务器完成对浏览器的连接请求进行解析处理，处理完之后给浏览器客户端返回一个响应。服务器后端的处理方式使用socket通信，利用IO多路复用技术可以同时监听多个请求，使用线程池处理请求，模拟Reactor事件模式，主线程只负责监听IO，监听到有事件之后，将IO请求对象放入请求队列交给工作线程处理，睡眠在请求队列上的工作线程被唤醒进行数据读取以及逻辑处理。</p>
<p><strong>整个服务的程序结构</strong></p>
<ul>
<li><code>Server</code>启动后，通过创建一个主线程套接字并绑定到指定的IP地址和端口。然后，它进入一个循环，等待传入的连接请求；</li>
<li>当有新的连接请求到达时，<code>Server</code>接受连接返回一个用于通信的Socket，并创建一个新的<code>HTTPCONN</code>实例来处理该连接。</li>
</ul>
<h4 id="改进过程中遇到的难点"><a href="#改进过程中遇到的难点" class="headerlink" title="改进过程中遇到的难点"></a>改进过程中遇到的难点</h4><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>Socket是一种用于在计算机之间进行通信的机制，它提供了一套标准的网络通信接口，使得不同的进程或者不同的计算机可以通过这一接口来进行数据交换。通过Socket接口，可以使用TCP或者UDP等协议在网络中进行通信。</p>
<p>通过Socket接口实现通信过程：</p>
<p><strong>服务端</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个用于监听的套接字</span><br><span class="line">    监听：监听有客户端的连接</span><br><span class="line">    套接字：这个套接字其实就是一个文件描述符</span><br><span class="line">2. 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）</span><br><span class="line">    客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line">3. 设置监听，监听的fd开始工作</span><br><span class="line">4. 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）一个新的fd</span><br><span class="line">5. 通信</span><br><span class="line">    接收数据</span><br><span class="line">    发送数据</span><br><span class="line">6. 通信结束，断开连接</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个用于通信的套接字（fd）</span><br><span class="line">2. 连接服务器，需要指定连接的服务器的 IP 和 端口</span><br><span class="line">    连接成功了，客户端可以直接和服务器通信</span><br><span class="line">3. 接收数据</span><br><span class="line">4. 发送数据</span><br><span class="line">5. 通信结束，断开连接</span><br></pre></td></tr></table></figure>

<p>而eventpoll是Linux系统中一种高效的I&#x2F;O多路复用机制，它可以同时监听多个文件描述符的状态，当其中任何一个文件描述符发生变化时，可以及时通知应用程序进行处理，从而避免了轮询等低效的方式。在网络编程中，eventpoll通常被用于监听多个socket的状态，以便及时处理传输的数据。</p>
<p><strong>简单的TCP网络程序</strong></p>
<p><img src="https://pic2.zhimg.com/v2-2a4a056a2d569fbe5b9bdf44b34510d5_r.jpg"></p>
<p><strong>UDP网络程序</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-c186c06cd82309d5c786c97d3f870bb0_720w.webp"></p>
<p>相对与TCP来说，UDP安全性差，面向无链接。所以UDP地实现少了连接请求与接收连接的操作；</p>
<p>TCP收发数据用函数send()和recv()，或者read()和write();</p>
<p>UDP收发数据用函数recvfrom()，sendto();</p>
<h4 id="IO复用技术"><a href="#IO复用技术" class="headerlink" title="IO复用技术"></a>IO复用技术</h4><p>是一种同步IO模型，实现同时监听多个文件描述符的IO事件，一旦某个IO事件就绪，就能够通知应用程序进行相应的读写操作；主要IO多路复用技术有<code>select</code>，<code>poll</code>和<code>epoll</code>；</p>
<p>​    </p>
<p><strong>select</strong><br>工作流程：</p>
<p>首先构造一个关于文件描述符的列表readfds，将要监听的文件描述符添加到该列表中，通过FD_SET将readfds中对应的文件描述符设为1<br>调用select，将文件描述符列表readfds copy到内核空间，监听该列表中的文件描述符，轮询感兴趣的fd，没有数据到来则select阻塞，直到这些文件描述符中的一个或者多个进行IO操作时，内核将对应位置为1并将结果返回用户空间。<br>用户空间遍历文件描述符列表readfds，通过FD_ISSET检测对应的fd是否置位，如果置位则调用read读取数据。<br>优点：可以监听多个文件描述符</p>
<p>缺点：</p>
<p>最大可监听文件描述符有上限，由fd_set决定（一般为1024）<br>需要将fd_set在用户态和内核态之间进行copy，开销大<br>无法精确知道哪些fd准备就绪，每次都需要遍历所有的fd<br>文件描述符列表集合不能重用，每次都需要重置。</p>
<p><strong>poll</strong></p>
<p><code>poll</code>跟<code>select</code>实现方式差不多,区别在于</p>
<ul>
<li><strong>没有最大可监听fd限制</strong>，因为其底层通过<strong>链表</strong>实现；</li>
<li><code>poll</code>内核通过<code>revents</code>来设置某些事件是否触发，所有每次不需要再重置</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">    <span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>epoll</strong></p>
<p>epoll是一种比select，poll更加高效的IO多路复用技术。epoll有三个重要接口：epoll_create, epoll_ctl, epoll_wait。</p>
<p>首先通过epoll_create在内核创建一个新的创建eventpoll结构体。</p>
<p>这个在内核创建的结构体有两个重要的数据，一个是需要检测的文件描述符信息，底层是红黑树， 增删改时间复杂度都为logn。另一个是就绪列表，存放所有有IO事件到来的fd（其共用红黑树的节点），底层是双向链表。</p>
<p>epoll_ctl是对这个实例进行管理，包括插入，删除和更新三个操作。</p>
<p>其中插入是使用socket fd及其关注的事件构造结构体，并插入到eventpoll中，同时会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表中。删除就是将socket fd对应的节点从eventpoll中删除，更新就是修改socket fd相关的信息，比如更改其所监听的事件等。</p>
<p>epoll_wait为检测函数，是一个阻塞的接口，如果就绪列表中有事件到来，就会将就绪事件copy到用户空间（通过epoll_event结构体），并返回事件的数量。没有数据就sleep，等到timeout时间到了即使没有数据也返回。</p>
<p>对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；<strong>epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都都需要执行一个系统调用。</strong></p>
<p>系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。</p>
<p><code>epoller_-&gt;Wait() 方法在内部会使用红黑树和双链表来管理文件描述符，并根据事件的发生情况进行处理。当调用 epoller_-&gt;Wait() 方法时，它会先从红黑树中获取所有需要监视的文件描述符，然后等待这些文件描述符上的事件发生。一旦有事件发生，就会将相应的文件描述符放入双链表的就绪链表中，最后将已经就绪的文件描述符返回给调用者。</code></p>
<h4 id="为什么ET模式下一定要设置非阻塞？"><a href="#为什么ET模式下一定要设置非阻塞？" class="headerlink" title="为什么ET模式下一定要设置非阻塞？"></a><strong>为什么ET模式下一定要设置非阻塞？</strong></h4><p><strong>阻塞IO</strong>：当我们对一个阻塞的文件描述符（阻塞IO）进行读写时，如果没有数据到来，就会卡在调用的函数上面直到有数据可以进行读写，Socket中可能阻塞的API：accept, recv,connect,send；</p>
<p><strong>非阻塞IO</strong>:读写一个非阻塞文件描述符的时候，无论是否可读写都会 立即返回结果。</p>
<p>· 成功：返回对应的结果。</p>
<p>· 失败：设置对应的errno</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cjfeii/article/details/115484558">no-block socket和阻塞socket的区别在于，no-block socket将socket设置为no-blocking，意味着socket收发数据都是非阻塞的，相比于阻塞方式，需要特殊处理这个错误码：EWOULDBLOCK or EAGAIN（这两个错误码是一样的，都是35），进行重试或者重新调度。而阻塞socket则是在读写数据时，如果没有数据可读或可写，会一直阻塞等待，直到有数据可读或可写。</a></p>
<p><strong>LT模式：</strong></p>
<p>如果文件描述符上有数据可读或可写缓冲区可写，那么在<code>整个数据读完或写完之前，epoll_wait() 会一直返回该文件描述符上有可读或可写事件</code>。</p>
<p>LT 模式是默认模式，通常使用非阻塞模式来监听文件描述符。<code>即使文件描述符被设置为阻塞模式，在 LT 模式下，epoll_wait() 仍然会立即返回，并告知文件描述符上有可读、可写或异常事件，而不会阻塞线程。</code>这意味着 LT 模式下，非阻塞模式和阻塞模式对于 epoll_wait() 的行为没有区别。</p>
<p><strong>ET模式：</strong></p>
<p>在 ET 模式下，<code>当一个文件描述符上有事件发生时，epoll_wait() 只会通知一次</code>，并且只有在文件描述符状态从无事件变为有事件时才会触发通知，<strong>所以需要使用循环一次性将读写操作完成。</strong></p>
<p>&#x3D;&#x3D;阻塞IO+ while循环&#x3D;&#x3D;，当最后一个数据读取完之后是跳不出循环的while(1){int len &#x3D; recv();}最后一次读不到进行了阻塞，卡在这了;</p>
<p>如果是&#x3D;&#x3D;非阻塞IO+while循环&#x3D;&#x3D;，当数据读取完之后recv就会立即返回-1，并且将errno进行设置，不会被卡在这里，性能提升;</p>
<p><strong>故而一般是ET+搭配非阻塞IO,ET在很大程度上减少了epoll事件被重复触发的次数，因此效率比LT高。</strong></p>
<h4 id="监听套接字为什么要设置成非阻塞的？"><a href="#监听套接字为什么要设置成非阻塞的？" class="headerlink" title="监听套接字为什么要设置成非阻塞的？"></a>监听套接字为什么要设置成非阻塞的？</h4><p><img src="https://gitee.com/juzihhu/image_bed/raw/master/img/202308040255889.png" alt="image-20230804025504436"></p>
<p>从图中可知，<strong>connect()会先于accep()函数返回。</strong></p>
<p>在listen_fd阻塞的情况下，当一个连接到来的时候，监听套接字可读，此时，我们稍微等一段时间之后再调用accept()。就在这段时间内，客户端设置linger选项(l_onoff &#x3D; 1, l_linger &#x3D; 0)，然后调用了close()，那么客户端将不经过四次挥手过程，通过发送RST报文断开连接。服务端接收到RST报文，系统会将排队的这个未完成连接直接删除，此时就相当于没有任何的连接请求到来， 而接着调用的accept()将会被阻塞，会导致整个线程阻塞在这里，无法继续处理其他已建立连接的读写操作或其他任务，直到另外的新连接到来时才会返回。</p>
<h4 id="EPOLLONESHOT"><a href="#EPOLLONESHOT" class="headerlink" title="EPOLLONESHOT"></a>EPOLLONESHOT</h4><p><code>EPOLLONESHOT</code> 是 Linux 下 epoll 事件注册时的一个标志，用于控制事件的触发方式。当一个文件描述符上的事件被设置为 <code>EPOLLONESHOT</code> 后，该事件在触发一次后将被自动禁用，直到重新调用 <code>epoll_ctl</code> 重新设置该事件的触发条件。</p>
<p>使用 <code>EPOLLONESHOT</code> 主要是为了避免多个线程同时处理同一个文件描述符的同一个事件，从而保证事件的原子性和顺序性。</p>
<h4 id="发送一个HTTP请求，服务器生成响应，怎么判断这个响应是否完整然后浏览器进行渲染？"><a href="#发送一个HTTP请求，服务器生成响应，怎么判断这个响应是否完整然后浏览器进行渲染？" class="headerlink" title="发送一个HTTP请求，服务器生成响应，怎么判断这个响应是否完整然后浏览器进行渲染？"></a>发送一个HTTP请求，服务器生成响应，怎么判断这个响应是否完整然后浏览器进行渲染？</h4><p>在发送 HTTP 请求后，服务器会生成响应并将其返回给客户端（浏览器）。浏览器接收到响应后，<strong>会根据响应头中的信息来判断响应是否完整，并根据响应的内容进行渲染。</strong></p>
<p>在 HTTP 响应中，有两个关键的头部字段用于判断响应是否完整：</p>
<ol>
<li>Content-Length：这个字段表示响应正文的长度，以字节为单位。浏览器会根据 Content-Length 字段的值来判断响应是否完整。如果 Content-Length 字段存在，并且与实际接收到的响应正文长度相符，那么浏览器会认为响应是完整的。</li>
<li>Transfer-Encoding：这个字段表示传输编码方式，常见的值有 “chunked” 和 “identity”。如果响应中使用了 chunked 传输编码，那么浏览器会根据每个数据块的长度来判断响应是否完整。</li>
</ol>
<p>当浏览器确定响应是完整的后，它会根据响应头中的 Content-Type 字段来判断响应的内容类型，然后使用相应的渲染引擎来处理和显示响应的内容。比如，对于 HTML 内容，浏览器会使用 HTML 渲染引擎来解析 HTML 标记并显示页面内容。</p>
<p>在渲染页面的过程中，浏览器会下载并加载页面中引用的其他资源，比如 CSS、JavaScript、图片等。这些资源会根据响应头中的信息来判断是否完整，然后进行渲染和显示。</p>
<p>总结起来，<code>浏览器通过解析响应头中的 Content-Length 字段和 Transfer-Encoding 字段来判断响应是否完整</code>，<strong>然后根据 Content-Type 字段来选择相应的渲染引擎对响应内容进行解析和渲染</strong>。这样，浏览器就能够正确显示服务器返回的页面内容。</p>
<h4 id="项目里如果一个HTTP请求不完整怎么判断？"><a href="#项目里如果一个HTTP请求不完整怎么判断？" class="headerlink" title="项目里如果一个HTTP请求不完整怎么判断？"></a>项目里如果一个HTTP请求不完整怎么判断？</h4><p>如果一个 HTTP 请求不完整，即服务器未能完整地接收到该请求，通常可以根据以下几种方式来判断：</p>
<ol>
<li>Content-Length 头部：HTTP 请求头部中的 Content-Length 字段表示请求正文的长度，以字节为单位。服务器可以通过 Content-Length 字段来判断请求是否完整。如果请求头部中包含 Content-Length 字段，并且服务器成功接收了指定长度的请求正文数据，则可以认为请求是完整的。</li>
<li>Transfer-Encoding 头部：HTTP 请求头部中的 Transfer-Encoding 字段表示传输编码方式，常见的值有 “chunked” 和 “identity”。如果请求中使用了 chunked 传输编码，服务器可以根据每个数据块的长度来判断请求是否完整。</li>
<li>Connection 头部：HTTP 请求头部中的 Connection 字段可以指定是否使用持久连接（keep-alive）。如果请求使用了持久连接，服务器可以根据 Connection 头部来判断是否继续等待接收后续的请求数据。</li>
<li>超时机制：服务器可以设置一个合适的超时时间，当超过该时间仍未接收到完整的请求数据时，可以判断请求不完整，并对其进行适当的处理。</li>
</ol>
<p>在实际应用中，服务器通常会结合多种方法来判断请求是否完整，以确保请求数据的完整性和准确性。如果服务器检测到请求不完整，可以返回适当的错误码（如 400 Bad Request）或其他错误信息，以便客户端重新发送完整的请求。</p>
<h4 id="内存映射是有名还是匿名？"><a href="#内存映射是有名还是匿名？" class="headerlink" title="内存映射是有名还是匿名？"></a>内存映射是有名还是匿名？</h4><p>内存映射可以有两种形式：有名内存映射和匿名内存映射。</p>
<ol>
<li>有名内存映射（Named Memory Mapping）：有名内存映射是通过在文件系统中创建一个特定的文件，然后将该文件映射到内存中。这样多个进程可以通过文件名来访问和共享同一块内存区域，从而实现进程间的共享数据。有名内存映射通常用于进程间的通信。</li>
<li>匿名内存映射（Anonymous Memory Mapping）：匿名内存映射是将一块未命名的内存区域映射到进程的地址空间中，该内存区域没有对应的文件，仅仅用于进程内部的数据交换。匿名内存映射通常用于进程内部的数据共享，或者在父子进程之间共享数据。</li>
</ol>
<p>在 Linux 系统中，有名内存映射可以通过 <code>mmap</code> 函数，并指定文件描述符和映射大小来实现；匿名内存映射可以通过 <code>mmap</code> 函数，并将文件描述符设置为 <code>MAP_ANONYMOUS</code> 来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有名内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">void</span>* addr1 = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名内存映射</span></span><br><span class="line">    <span class="type">void</span>* addr2 = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用映射后的内存进行读写操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    <span class="built_in">munmap</span>(addr1, <span class="number">4096</span>);</span><br><span class="line">    <span class="built_in">munmap</span>(addr2, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="两种事件的处理模式"><a href="#两种事件的处理模式" class="headerlink" title="两种事件的处理模式"></a>两种事件的处理模式</h4><p><strong>Reactor模式</strong></p>
<p>要求<strong>主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生</strong>，有的话就立即将该事件通知工作线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p>
<p><strong>使用同步 I&#x2F;O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：</strong></p>
<ol>
<li><p>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</p>
</li>
<li><p>主线程调用 epoll_wait 等待 socket 上有数据可读。</p>
</li>
<li><p>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</p>
</li>
<li><p>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll内核事件表中注册该 socket 上的写就绪事件。</p>
</li>
<li><p>当主线程调用 epoll_wait 等待 socket 可写。</p>
</li>
<li><p>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</p>
</li>
<li><p>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</p>
</li>
</ol>
<p><strong>Proactor模式</strong></p>
<p>Proactor 模式将所有 I&#x2F;O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻<br>辑。使用异步 I&#x2F;O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式</p>
<p><strong>区别及优缺点</strong></p>
<p><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</p>
<p>优缺点：</p>
<p>Reactor实现相对简单，对于耗时短的处理场景处理高效；<strong>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁</strong>；</p>
<p>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</p>
<p><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</p>
<p>优缺点</p>
<p>Proactor性能更高，这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）</p>
<p>Proactor实现逻辑复杂；依赖操作系统对异步的支持。</p>
<p><strong>Reactor 可以理解为来了事件操作系统通知应用进程，让应用进程来处理，而 Proactor 可以理解为来了事件操作系统来处理，处理完再通知应用进程。</strong></p>
<h4 id="线程池设计与实现"><a href="#线程池设计与实现" class="headerlink" title="线程池设计与实现"></a>线程池设计与实现</h4><ol>
<li><p><code>ThreadPool</code> 类定义了一个线程池，它可以在构造函数中指定线程数量。线程池的主要作用是接受任务并分配给可用线程来执行。</p>
</li>
<li><p><code>Pool</code> 结构是线程池的内部私有结构，包含以下成员：</p>
<ul>
<li><code>std::mutex mtx</code>：用于保护线程池内部数据结构的互斥锁。</li>
<li><code>std::condition_variable cond</code>：用于线程之间的条件变量，用于通知等待中的线程任务可用或线程池关闭。</li>
<li><code>bool isClosed</code>：标志线程池是否已关闭。</li>
<li><code>std::queue&lt;std::function&lt;void()&gt;&gt; tasks</code>：任务队列，用于存储待执行的任务。</li>
</ul>
</li>
<li><p>在线程池的构造函数中，它会创建指定数量的工作线程，每个线程会不断地从任务队列中取出任务并执行。这些工作线程会一直运行，直到线程池被销毁。</p>
</li>
<li><p>构造函数中的循环使用<code>std::thread</code>创建了多个工作线程。每个线程都会执行一个lambda函数，该函数会在获取任务时执行任务，并且在任务队列为空且线程池未关闭时等待条件变量通知。</p>
</li>
<li><p>析构函数会在销毁线程池时被调用。它首先将线程池标记为已关闭（<code>pool_-&gt;isClosed = true</code>），然后通过条件变量通知所有等待的线程，以便它们可以退出。这确保线程池的资源得到正确释放。</p>
</li>
<li><p><code>AddTask</code> 方法用于向线程池提交任务。它会将任务添加到任务队列，并通过条件变量通知等待中的线程有新任务可执行。</p>
</li>
</ol>
<p>这段代码实现了一个基本的线程池，它管理一组工作线程，可以接受任务并在这些线程中执行。通过使用互斥锁和条件变量，它确保线程之间的协同工作，同时处理任务队列和线程池的关闭。这种线程池可用于提高并发性能，减少线程创建和销毁的开销。</p>
<h5 id="std-shared-ptr-lt-Pool-gt-pool"><a href="#std-shared-ptr-lt-Pool-gt-pool" class="headerlink" title="std::shared_ptr&lt;Pool&gt; pool_;"></a><code>std::shared_ptr&lt;Pool&gt; pool_;</code></h5><p>是一个成员变量，它是一个指向 <code>Pool</code> 结构的 <code>std::shared_ptr</code> 智能指针。这里之所以使用 <code>std::shared_ptr</code>，是为了确保线程池的正确生命周期管理，以防止内存泄漏和资源泄漏，并允许多个地方引用相同的线程池实例。</p>
<p><strong>下面是为什么使用 <code>std::shared_ptr</code> 的一些理由：</strong></p>
<ol>
<li><p><strong>生命周期管理</strong>：<code>std::shared_ptr</code> 允许多个对象（例如，线程池的构造函数和析构函数）共享对 <code>Pool</code> 实例的引用。这确保只有在最后一个引用被销毁时，<code>Pool</code> 实例才会被销毁。这有助于确保线程池在使用它的所有地方都保持有效。</p>
</li>
<li><p><strong>避免资源泄漏</strong>：如果线程池是通过裸指针或其他方式管理的，可能会出现资源泄漏的情况，因为线程池在某些情况下可能无法被正确销毁。使用 <code>std::shared_ptr</code> 可以确保在不再需要线程池时自动释放它。</p>
</li>
<li><p><strong>线程安全</strong>：<code>std::shared_ptr</code> 本身是线程安全的，多个线程可以同时访问和修改共享的引用计数。这确保了在多线程环境中对线程池的引用操作是安全的。</p>
</li>
<li><p><strong>方便的拷贝和传递</strong>：<code>std::shared_ptr</code> 可以方便地进行拷贝和传递，而不需要手动管理引用计数。这使得在不同地方使用线程池更加方便。</p>
</li>
</ol>
<p>总之，使用 <code>std::shared_ptr</code> 可以简化线程池的生命周期管理，提高代码的可维护性，并确保在线程池的所有地方都可以正确引用和使用它，同时保证资源的正确释放。这是一种常见的 C++ 内存管理和资源管理模式。</p>
<h5 id="pool-gt-cond-notify-one-："><a href="#pool-gt-cond-notify-one-：" class="headerlink" title="pool_-&gt;cond.notify_one() ："></a><code>pool_-&gt;cond.notify_one()</code> ：</h5><ol>
<li><strong>通知等待中的一个线程</strong>：如果有线程因为等待条件变量而被阻塞，它们中的一个会被唤醒。这是因为 <code>notify_one()</code> 会唤醒一个等待的线程，但不会唤醒所有。</li>
<li><strong>继续执行等待的线程</strong>：被唤醒的线程将检查条件是否满足，如果满足条件，它将继续执行；否则，它将继续等待。</li>
</ol>
<p>在线程池的 <code>AddTask</code> 方法中，<code>pool_-&gt;cond.notify_one()</code> 用于通知等待的线程，以便它们可以检查任务队列中是否有新任务可用。如果有一个或多个线程正在等待条件变量（例如，在调用 <code>pool_-&gt;cond.wait(locker)</code> 时），则其中的一个线程将被唤醒，以便它可以获取新的任务并执行它。</p>
<p>唤醒哪个阻塞的线程的具体机制可以分为以下几种情况：</p>
<ol>
<li><p><strong>不确定性唤醒（Non-deterministic Wakeup）</strong>：</p>
<p>在一般情况下，当多个线程等待同一个条件变量时，调度器通常会选择其中一个线程唤醒，但不能确定唤醒的顺序。这就是为什么在使用 <code>notify_one()</code> 时，不能确定哪个线程会被唤醒。</p>
</li>
<li><p><strong>优先级（Priority）</strong>：</p>
<p>有些操作系统的线程调度器可能会考虑线程的优先级，更高优先级的线程可能更容易被唤醒。但这取决于操作系统和调度器的实现。</p>
</li>
<li><p><strong>先到先服务（First-Come-First-Served）</strong>：</p>
<p>在某些情况下，调度器可能会按照线程进入等待状态的顺序来唤醒线程，这就是所谓的“先到先服务”原则。但这也不是所有情况下都成立的。</p>
</li>
<li><p><strong>随机性（Randomness）</strong>：</p>
<p>在某些情况下，线程唤醒的顺序可能会具有随机性，这是为了防止线程饥饿和提高公平性。</p>
</li>
</ol>
<h5 id="互斥锁（Mutex）和条件变量（Condition-Variable）"><a href="#互斥锁（Mutex）和条件变量（Condition-Variable）" class="headerlink" title="互斥锁（Mutex）和条件变量（Condition Variable）"></a>互斥锁（Mutex）和条件变量（Condition Variable）</h5><p><strong>互斥锁用于保护共享资源的访问，而条件变量用于在线程之间传递信息和控制线程的执行流程</strong>。它们通常一起使用，以实现复杂的多线程同步和协作。，它们有以下主要区别：</p>
<ol>
<li><p><strong>作用和用途</strong>：</p>
<ul>
<li><p><strong>互斥锁</strong>：主要用于保护共享资源的访问，确保同一时刻只有一个线程可以访问共享资源。当一个线程获得互斥锁时，其他线程会被阻塞，直到互斥锁被释放。</p>
</li>
<li><p><strong>条件变量</strong>：用于在线程之间传递信息和控制线程的执行流程。它通常与互斥锁结合使用，允许线程等待某个条件的发生，并在条件满足时被唤醒。</p>
</li>
</ul>
</li>
<li><p><strong>主要操作</strong>：</p>
<ul>
<li><p><strong>互斥锁</strong>：主要有两个操作，即锁定（Lock）和解锁（Unlock）。线程可以尝试锁定互斥锁，如果锁已被其他线程锁定，则会被阻塞，直到锁可用。</p>
</li>
<li><p><strong>条件变量</strong>：主要有三个操作，即等待（Wait）、通知（Notify）和广播（Broadcast）。线程可以等待在条件变量上，等待某个条件的满足。其他线程可以通过通知或广播来唤醒等待的线程。</p>
</li>
</ul>
</li>
<li><p><strong>关联性</strong>：</p>
<ul>
<li><p><strong>互斥锁</strong>：通常与共享资源一起使用，用于保护对共享资源的访问，防止多个线程同时修改共享资源，从而避免数据竞争和不一致性。</p>
</li>
<li><p><strong>条件变量</strong>：通常与互斥锁结合使用。条件变量允许线程等待某个条件的发生，而这个条件通常与共享资源的状态相关。条件变量的等待通常包含在临界区内，以确保线程在等待和被唤醒期间不会出现竞态条件。</p>
</li>
</ul>
</li>
<li><p><strong>等待机制</strong>：</p>
<ul>
<li><p><strong>互斥锁</strong>：不提供等待机制。如果一个线程无法获取互斥锁，它会被阻塞，直到互斥锁可用。</p>
</li>
<li><p><strong>条件变量</strong>：提供了等待和唤醒机制。线程可以等待在条件变量上，直到其他线程通过通知或广播唤醒它们。</p>
</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li><p><strong>互斥锁</strong>：适用于任何需要保护共享资源的情况，如临界区保护、互斥访问共享数据等。</p>
</li>
<li><p><strong>条件变量</strong>：适用于需要线程等待特定条件的情况，如生产者-消费者问题、线程间通信、任务调度等。</p>
</li>
</ul>
</li>
</ol>
<h4 id="HTTP请求解析"><a href="#HTTP请求解析" class="headerlink" title="HTTP请求解析"></a>HTTP请求解析</h4><h4 id="现自动增长的缓冲区"><a href="#现自动增长的缓冲区" class="headerlink" title="现自动增长的缓冲区"></a>现自动增长的缓冲区</h4><h4 id="小根堆实现的定时器"><a href="#小根堆实现的定时器" class="headerlink" title="小根堆实现的定时器"></a>小根堆实现的定时器</h4><p><code>timer_-&gt;add(fd, timeoutMS_, std::bind(&amp;WebServer::CloseConn_, this, &amp;users_[fd]));</code></p>
<p>为fd对应的连接添加一个超时定时器,超时时间为timeoutMS_毫秒。如果在timeoutMS_毫秒内没有接收到客户端的数据,则执行回调函数:std::bind(&amp;WebServer::CloseConn_, this, &amp;users_[fd])这个回调函数的作用是:调用WebServer对象的CloseConn_方法关闭fd对应的连接。</p>
<p><strong>定时器的核心逻辑</strong>:通过维护一个定时器堆和时间戳来管理定时器,所有的功能实现都是围绕堆展开的。主要通过调整堆实现添加定时器、 删除定时器、调整定时器等功能。tick()函数通过不断检查堆顶是否超时来执行定时回调。</p>
<p>timer_是作为全局定时器存在的,它由主线程创建,但不属于任何特定的工作线程。各连接创建的定时器事件由timer_统一管理</p>
<p>timer_是HeapTimer类型的对象,在WebServer构造函数中实例化。它负责存储和管理所有的定时器事件。_</p>
<p>每个新连接通过<code>void WebServer::AddClient_(int fd, sockaddr_in addr)</code>方法添加到WebServer中。在该方法中,通过<code>timer_-&gt;add()</code>为连接创建一个定时器事件,并将其添加到timer_中。timer_会为每个定时器事件维护其超时时间timeout。并通过时间循环反复检查当前时间,判断哪些定时器事件已经超时。</p>
<p><strong>timer_设计为unique_ptr主要有以下好处:</strong></p>
<ol>
<li>可以灵活重置指向其他定时器,方便功能变更。</li>
<li>生命周期绑定到WebServer,但可以被重置完全控制。</li>
<li>避免了手动管理内存的麻烦,减少内存泄漏的可能。</li>
<li>体现了RAII的思想,简化了定时器资源的管理。</li>
<li>易读易维护,符合现代C++代码的习惯。</li>
</ol>
<h4 id="利用单例模式与阻塞队列实现异步的日志系统"><a href="#利用单例模式与阻塞队列实现异步的日志系统" class="headerlink" title="利用单例模式与阻塞队列实现异步的日志系统"></a>利用单例模式与阻塞队列实现异步的日志系统</h4><p>在这个WebServer构造函数中,日志系统被设计为:</p>
<ol>
<li><p>单例模式:Log::Instance()返回日志系统的唯一实例,简化了日志系统的创建和使用。</p>
</li>
<li><p>阻塞队列:日志信息通过阻塞队列logQueSize缓存,然后由日志线程 asynchronously 写入文件。</p>
</li>
<li><p>异步写入:日志线程会不断从阻塞队列中取出日志消息,写入日志文件。而业务线程只需要将日志消息插入队列,不等待写入完成。</p>
</li>
</ol>
<p>所以,日志系统的工作流程是</p>
<ol>
<li><p>WebServer构造函数调用Log::Instance()初始化日志系统,设置日志级别logLevel和日志文件路径等信息。</p>
</li>
<li><p>业务线程(如工作线程)产生日志消息后,调用LOG_INFO或LOG_ERROR将消息插入阻塞队列。</p>
</li>
<li><p>不等待日志消息写入完成,业务线程可以继续处理其他任务。</p>
</li>
<li><p>日志线程会反复检查阻塞队列,如果有日志消息,则取出并写入日志文件。</p>
</li>
<li><p>日志消息的生成和写入是异步的,通过阻塞队列实现解耦。</p>
</li>
</ol>
<p>那么,这种日志系统设计的优点是：</p>
<ol>
<li>单例模式简化了日志系统的使用,只需要调用Log::Instance()即可获得日志对象。</li>
<li>异步写入提高了业务线程的执行效率,不会被日志写入阻塞。</li>
<li>阻塞队列作为缓冲,可以防止日志消息溢出,并解耦日志的生成和写入。</li>
<li>日志系统的工作线程独立于其他任何业务线程,可独立运行。</li>
</ol>
<p><strong>在WebServer的日志系统中,日志线程是专门用于异步写入日志消息的线程。它与主线程和其他业务线程(如工作线程)的关系如下:</strong></p>
<ol>
<li>日志线程在WebServer构造函数中被创建,用于异步写入日志消息。它独立运行,不属于任何业务线程。</li>
<li>主线程通过InitEventMode_、InitSocket_等方法完成服务器环境初始化工作。如果初始化成功且开启日志,还会通过Log::Instance()初始化日志系统。</li>
<li>日志系统初始化后,主线程继续监听连接和分配任务。日志线程开始通过阻塞队列读取日志消息并写入日志文件。</li>
<li>各业务线程(工作线程等)运行并产生日志消息,通过LOG_INFO或LOG_ERROR将消息插入阻塞队列,并不等待写入。</li>
<li>日志线程会不断从阻塞队列读取新的日志消息,写入日志文件完成异步写入功能。</li>
<li>即使业务线程结束,只要日志系统存在,日志线程会继续运行读取插入队列的日志消息。</li>
<li>日志线程与具体的业务线程无关,它仅作用于日志系统这个中间层,将日志消息从生成线程异步传递到写入线程。</li>
</ol>
<p>所以,可以看出:</p>
<ol>
<li>日志线程是WebServer构造函数创建,用于异步写入日志消息。它独立于任何业务线程运行。</li>
<li>主线程用于初始化服务器环境,包括日志系统。各业务线程用于运行业务逻辑和产生日志消息。</li>
<li>日志消息的生成属于各业务线程,但写入属于日志线程。两者之间通过阻塞队列解耦。</li>
<li>尽管业务线程结束,只要日志系统存在,日志线程会继续运行。它与特定的业务线程无直接关联。</li>
<li>日志线程作为中间层,实现了日志消息从生成线程到写入线程的异步传递。<br>所以,日志线程实际上充当了消息队列或中间件的角色,实现了日志系统的异步功能。</li>
</ol>
<h4 id="线程池的线程数量一般怎么设置？"><a href="#线程池的线程数量一般怎么设置？" class="headerlink" title="线程池的线程数量一般怎么设置？"></a>线程池的线程数量一般怎么设置？</h4><p><strong>CPU密集：</strong></p>
<p>CPU密集的意思是该任务需要大量的运算，只有在真正的多核CPU上才可能得到加速，CPU密集型任务配置尽可能少的线程数量：<strong>CPU核数+1个线程的线程池</strong></p>
<p><strong>IO密集型：</strong></p>
<p>即该任务需要大量的IO，即大量的阻塞。在单线程上运IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待；参考公式：<strong>CPU核数*2</strong>；<strong>CPU核数 &#x2F;（1 - 阻系数）</strong>（阻塞系数在0.8~0.9之间）；</p>
<h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><p>连接池的基本思想就是在初始化时，将数据库连接对象保存在内存中，当用户需要访问数据库时，并非新建一个连接，而是从连接池中取出一个空闲的连接对象；使用完毕后，也并非直接断开连接，而是重新放到连接池中。以达到避免频繁连接断开数据库，提高数据库的处理效率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL* <span class="title">SqlConnPool::GetConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL *sql = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(connQue_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;SqlConnPool busy!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;semId_);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        sql = connQue_.<span class="built_in">front</span>();</span><br><span class="line">        connQue_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::FreeConn</span><span class="params">(MYSQL* sql)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sql);</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    connQue_.<span class="built_in">push</span>(sql);</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semId_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据连接池的基本思想，我们设计一个数据库连接池<code>SqlConnPool</code>，如下：</p>
<ul>
<li>单例模式，保证进程唯一</li>
<li>使用queue来管理数据库连接对象(静态大小)</li>
<li>互斥锁实现线程安全</li>
</ul>
<p>池提供了连接对象的获取和释放接口，但是在实际使用中，需要使用者记得在使用完毕后去释放连接对象，这样的设计并不友好，因此我们添加一个数据库操作类<code>SqlConnRAII</code>，利用RAII来封装下数据库连接池，这样可以确保在使用完连接对象后，操作类会帮助我们析构释放对象。</p>
<h4 id="并发编程中常见的三类并发问题"><a href="#并发编程中常见的三类并发问题" class="headerlink" title="并发编程中常见的三类并发问题"></a>并发编程中常见的三类并发问题</h4><p>通常称为 “原子性”、”可见性” 和 “顺序性” 问题。</p>
<ol>
<li><p><strong>原子性（Atomicity）问题</strong>：</p>
<ul>
<li><p><strong>问题描述</strong>：原子性问题涉及到操作的不可分割性。在多线程环境中，如果一个操作被拆分成多个子操作，而其他线程可以在其中某个子操作执行期间干扰该操作，那么就可能导致不一致或错误的结果。</p>
</li>
<li><p><strong>解决方式</strong>：使用互斥锁、原子操作、事务等机制来确保关键操作的原子性，以防止其他线程的干扰。</p>
</li>
</ul>
</li>
<li><p><strong>可见性（Visibility）问题</strong>：</p>
<ul>
<li><p><strong>问题描述</strong>：可见性问题涉及到线程之间共享数据的可见性。当一个线程修改共享变量的值时，其他线程可能无法立即看到这个变化，导致数据不一致性。</p>
</li>
<li><p><strong>解决方式</strong>：使用同步机制（如互斥锁、volatile关键字、原子操作、条件变量等）来确保共享数据的可见性，以便一个线程对共享变量的修改对其他线程是可见的。</p>
</li>
</ul>
</li>
<li><p><strong>顺序性（Ordering）问题</strong>：</p>
<ul>
<li><p><strong>问题描述</strong>：顺序性问题涉及到操作的执行顺序。在多线程环境中，线程执行的顺序可能会受到编译器优化、CPU指令重排等因素的影响，导致不符合预期的执行顺序。</p>
</li>
<li><p><strong>解决方式</strong>：使用同步机制来明确定义线程之间操作的执行顺序，如互斥锁、volatile关键字、内存屏障等，以确保操作按照期望的顺序执行。</p>
</li>
</ul>
</li>
</ol>
<p>这些并发问题是多线程编程中需要仔细考虑的关键问题，因为它们可能导致不确定的行为、竞态条件、数据损坏等问题。解决这些问题通常需要谨慎设计和使用同步机制，以确保多线程程序的正确性和可靠性。</p>
<p>举例：</p>
<p><code>volatile</code> 的作用是告诉编译器不要对 <code>flag</code> 变量进行优化，确保在多线程环境中对 <code>flag</code> 的读取和写入不会被编译器重排或优化掉。这可以解决可见性问题，因为它确保了一个线程对 <code>flag</code> 的修改对其他线程是可见的。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/552580039">https://zhuanlan.zhihu.com/p/552580039</a></p>
<h2 id="七、自我介绍"><a href="#七、自我介绍" class="headerlink" title="七、自我介绍"></a>七、自我介绍</h2><p>下面我从两个方面进行自我介绍，</p>
<p>第一是我的在校经历，我本科就读于河海大学计算机科学与技术；研究生就读的是电子信息-计算机技术专业，在校期间有过学业优秀奖学金以及班级团支书、校长学生事务助理等学生工作经验，参与过两次重大的体育赛事，分别是江苏省第十九届运动会和武汉第七届世界军人运动会，在其中担任电子裁判和成绩处理工程师，负责竞赛成绩系统的测试与成绩实时展示，这两次实践经历锻炼了我对于大规模赛事下工作对接沟通的抗压能力以及赛事系统功能测试方面的经验；</p>
<p>第二是我的研究方向，我研究生阶段的研究方向的医学图像分割以及三维仿真，基于介入手术的背景实现了对子宫动脉血管的分割以及三维重建，并基于物理引擎实现基础的模拟；此外也有过HTTP服务器实现，CATIA二次开发、经典战例兵棋推演系统的测试等项目经验，能够熟练使用c++语言，熟悉STL、智能指针、Lambda表达式以及单例模式的实践应用;</p>
<h2 id="八、测试岗位"><a href="#八、测试岗位" class="headerlink" title="八、测试岗位"></a>八、测试岗位</h2><h3 id="黑盒与白盒的测试方法"><a href="#黑盒与白盒的测试方法" class="headerlink" title="黑盒与白盒的测试方法"></a>黑盒与白盒的测试方法</h3><p><strong>黑盒测试：</strong></p>
<p>在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否正常，程序是否能接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。</p>
<p>常用的黑盒测试方法有：等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。</p>
<ul>
<li><p>等价类划分是将系统的输入域划分为若干部分，然后从每个部分选取少量代表性数据进行测试。</p>
</li>
<li><p>边界值分析法是对等价类划分的一种补充，因为大多数错误都在输入输出的边界上。<strong>边界值分析就是假定大多数错误出现在输入条件的边界上，如果边界附件取值不会导致程序出错，那么其他取值出错的可能性也就很小。</strong></p>
</li>
</ul>
<p><strong>白盒测试：</strong></p>
<p>白盒测试是检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法；</p>
<p>常用白盒测试方法：</p>
<ul>
<li><p>静态测试：不用运行程序的测试，包括代码检查、静态结构分析、代码质量度量、文档测试等等</p>
</li>
<li><p>动态测试：需要执行代码，通过运行程序找到问题，包括功能确认与接口测试、覆盖率分析、性能分析、内存分析等。</p>
</li>
</ul>
<h3 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h3><ul>
<li>软件测试的核心竞争力是什么?</li>
<li>测试和开发需要怎样去沟通与结合？</li>
</ul>
<h2 id="九、网络编程"><a href="#九、网络编程" class="headerlink" title="九、网络编程"></a>九、网络编程</h2><h3 id="thread的使用"><a href="#thread的使用" class="headerlink" title="thread的使用"></a>thread的使用</h3><p>thread是一个类，可以通过创建类对象来创建一个新线程，并通过初始化来关联一个可执行对象，使线程完成特定的工作。</p>
<p>当创建一个线程对象后，并且给线程关联<strong>线程函数</strong>，该线程就被启动，与主线程一起运行。线程函数一般情况下可按照以下三种方式提供：</p>
<ul>
<li>函数指针</li>
<li>lambda表达式</li>
<li>函数对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadFunc</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Thread1&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TF</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Thread3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 线程函数为函数指针</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(ThreadFunc, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 线程函数为lambda表达式</span></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">([]&#123;cout &lt;&lt; <span class="string">&quot;Thread2&quot;</span> &lt;&lt; endl; &#125;)</span></span>;</span><br><span class="line">	<span class="comment">// 线程函数为函数对象</span></span><br><span class="line">	TF tf;</span><br><span class="line">	<span class="function">thread <span class="title">t3</span><span class="params">(tf)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	t3.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Main thread!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程函数的参数是以值拷贝的方式拷贝到线程栈空间中的，因此：即使线程参数为引用类型，在线程中修改后也不能修改外部实参，因为其实际引用的是线程栈中的拷贝，而不是外部实参</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadFunc1</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">	x += <span class="number">10</span>;&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadFunc2</span><span class="params">(<span class="type">int</span>* x)</span></span>&#123;</span><br><span class="line">	*x += <span class="number">10</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//在线程函数中对a修改，不会影响外部实参，</span></span><br><span class="line">    <span class="comment">//因为：线程函数参数虽然是引用方式，但其实际引用的是线程栈中的拷贝</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(ThreadFunc1, a)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 如果想要通过形参改变外部实参时，必须借助std::ref()函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(ThreadFunc1, std::ref(a))</span></span>;</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 地址的拷贝</span></span><br><span class="line">	<span class="function">thread <span class="title">t3</span><span class="params">(ThreadFunc2, &amp;a)</span></span>;</span><br><span class="line">	t3.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="join与detach"><a href="#join与detach" class="headerlink" title="join与detach"></a>join与detach</h3><p>当这个线程结束的时候，可以使用<code>detach()与join()</code>回收线程所使用的资源：</p>
<ul>
<li><p>当使用join()函数时，主调线程阻塞，等待被调线程终止，然后主调线程回收被调线程资源，并继续运行；</p>
</li>
<li><p>当使用detach()函数时，主调线程继续运行，被调线程驻留后台运行，主调线程无法再取得该被调线程的控制权。当主调线程结束时，由运行时库负责清理与被调线程相关的资源。</p>
</li>
</ul>
<h3 id="多线程交替打印"><a href="#多线程交替打印" class="headerlink" title="多线程交替打印"></a>多线程交替打印</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printChar</span><span class="params">(<span class="type">char</span> ch, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [target]() &#123; <span class="keyword">return</span> count % <span class="number">3</span> == target; &#125;);</span><br><span class="line">        std::cout &lt;&lt; ch;</span><br><span class="line">        ++count;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printChar, <span class="string">&#x27;A&#x27;</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printChar, <span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(printChar, <span class="string">&#x27;C&#x27;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程对多个文件内的数字求和"><a href="#多线程对多个文件内的数字求和" class="headerlink" title="多线程对多个文件内的数字求和"></a>多线程对多个文件内的数字求和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> totalSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processFile</span><span class="params">(<span class="type">const</span> std::string &amp;filename)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> localSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (file &gt;&gt; num) &#123;</span><br><span class="line">    localSum += num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  totalSum += localSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  std::vector&lt;std::string&gt; path&#123;<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;c.txt&quot;</span>&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;begin \n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(processFile, path[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : threads) &#123;</span><br><span class="line">    thread.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Total sum: &quot;</span> &lt;&lt; totalSum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="C-确保线程安全的几种方式？代码举例"><a href="#C-确保线程安全的几种方式？代码举例" class="headerlink" title="C++确保线程安全的几种方式？代码举例"></a>C++确保线程安全的几种方式？代码举例</h3><ul>
<li><p><strong>互斥锁</strong>：互斥锁是一种简单但有效的线程安全机制。它用于确保对共享资源的访问是线程安全的。</p>
</li>
<li><p><strong>条件变量</strong>：条件变量用于等待某个条件变为真。它通常与互斥锁一起使用，以确保等待条件变量的线程不会被其他线程打断。</p>
</li>
<li><p><strong>原子操作</strong>：原子操作是保证在多线程环境下操作是原子性的操作。这意味着操作不会被其他线程打断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个原子变量</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原子变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 原子地增加计数器</span></span><br><span class="line">  ++counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>线程局部存储</strong>：线程局部存储是每个线程都有自己一个副本的变量。这可以防止多个线程访问同一个变量导致数据竞争。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个线程局部变量</span></span><br><span class="line">std::<span class="keyword">thread_local</span> <span class="type">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用线程局部变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 原子地增加计数器</span></span><br><span class="line">  ++counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>使用了 <code>std::mutex</code> 和 <code>std::lock_guard&lt;std::mutex&gt;</code></p>
<p><code>std::lock_guard</code> 是一个 RAII（Resource Acquisition Is Initialization）机制的实现，它会在构造时自动加锁，析构时自动解锁，从而确保在任何情况下都会正确地释放互斥锁，避免了因为异常或返回等情况下忘记解锁的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 定义一个互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 使用std::lock_guard自动管理锁的生命周期</span></span><br><span class="line">    <span class="comment">// 访问共享资源的代码</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is accessing the shared resource.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">5</span>;</span><br><span class="line">    std::thread threads[numThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(threadFunction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol>
<li>定义互斥锁：首先需要定义一个互斥锁变量，一般使用 <code>std::mutex</code> 类型。</li>
<li>加锁：在进入临界区前，使用 <code>lock()</code> 或 <code>try_lock()</code> 方法来获取互斥锁的所有权。<code>lock()</code> 方法会阻塞当前线程，直到成功获取锁，而 <code>try_lock()</code> 方法会尝试立即获取锁，如果锁已经被其他线程占有，它会立即返回而不是阻塞。</li>
<li>访问共享资源：一旦成功获取了互斥锁的所有权，当前线程就可以进入临界区，访问共享资源。</li>
<li>解锁：在临界区访问共享资源结束后，使用 <code>unlock()</code> 方法释放互斥锁，使其他线程有机会获得锁，继续访问共享资源。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 定义互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> threadID)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>(); <span class="comment">// 加锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadID &lt;&lt; <span class="string">&quot; is entering the critical section.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadID &lt;&lt; <span class="string">&quot; is accessing the shared resource.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">5</span>;</span><br><span class="line">    std::thread threads[numThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(threadFunction, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  cv.<span class="built_in">wait</span>(lock, []() -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件变量ready为true</span></span><br><span class="line">  <span class="comment">// 在等待期间，线程会释放互斥锁，阻塞等待被唤醒</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Worker thread is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">worker</span><span class="params">(workerThread)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line"></span><br><span class="line">  worker.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码演示了如何使用条件变量（<code>std::condition_variable</code>）来实现线程间的同步和通信。代码中包含一个工作线程（<code>workerThread</code>）和主线程（<code>main</code>）。它们之间通过条件变量和互斥锁来实现同步，确保工作线程在满足特定条件时被唤醒执行。</p>
<ol>
<li><p>在主线程中，首先创建了一个工作线程 <code>worker</code>，并在工作线程开始执行前延迟2秒钟（<code>std::this_thread::sleep_for(std::chrono::seconds(2))</code>）。这是为了模拟在工作线程执行前需要等待的情况。</p>
</li>
<li><p>接下来，主线程获取了互斥锁 <code>mtx</code>，并将条件变量 <code>ready</code> 设置为 <code>true</code>。这里使用了 <code>std::lock_guard</code> 简化了互斥锁的管理。条件变量 <code>ready</code> 表示工作线程可以开始执行了。</p>
</li>
<li><p>在设置了 <code>ready</code> 后，主线程通过 <code>cv.notify_one()</code> 唤醒了等待的工作线程。<code>notify_one()</code> 用于通知等待在条件变量上的一个线程，以便它继续执行。</p>
</li>
<li><p>工作线程 <code>workerThread</code> 中，首先获取了互斥锁 <code>mtx</code>，然后调用 <code>cv.wait(lock, [] &#123; return ready; &#125;)</code>。<code>cv.wait()</code> 是一个条件变量的等待操作，它会使得当前线程阻塞等待，直到条件变量 <code>ready</code> 的值为 <code>true</code>。在等待期间，工作线程会释放互斥锁 <code>mtx</code>，允许其他线程进入临界区。</p>
</li>
<li><p>当主线程将 <code>ready</code> 设置为 <code>true</code> 并调用 <code>cv.notify_one()</code> 后，工作线程收到通知被唤醒，它再次尝试获取互斥锁 <code>mtx</code>。一旦成功获取锁，工作线程继续执行，并输出 “Worker thread is running.”。</p>
</li>
</ol>
<p>通过这种方式，我们实现了主线程与工作线程之间的同步和通信。主线程通过设置 <code>ready</code> 条件变量，唤醒了工作线程的等待，并让工作线程在条件满足时继续执行。使用条件变量可以避免线程的忙等待，节省了系统资源，提高了线程的效率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件变量ready为true</span></span><br><span class="line">    <span class="comment">// 在等待期间，线程会释放互斥锁，阻塞等待被唤醒</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is running. Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numThreads = <span class="number">5</span>;</span><br><span class="line">    std::thread threads[numThreads];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个工作线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(workerThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟2秒钟</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒等待的工作线程</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有工作线程执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意到 <code>cv.notify_all()</code> 用于唤醒所有等待在条件变量 <code>cv</code> 上的工作线程，而不再是之前的 <code>cv.notify_one()</code>。因为有多个工作线程在等待，我们需要全部唤醒，以确保它们都能继续执行。</p>
<h3 id="Linux子进程创建没有wait操作会发生什么"><a href="#Linux子进程创建没有wait操作会发生什么" class="headerlink" title="Linux子进程创建没有wait操作会发生什么"></a>Linux子进程创建没有wait操作会发生什么</h3><p>在 Linux 中，如果父进程创建了子进程，而没有等待子进程终止的操作（比如使用 <code>wait()</code> 或 <code>waitpid()</code> 函数），则子进程会成为一个僵尸进程（Zombie Process）。</p>
<p>僵尸进程是指一个子进程已经终止（通过调用 <code>exit()</code> 或者由于异常终止），但是其父进程还没有对其进行回收资源的操作。在这种情况下，子进程的进程表项仍然存在，但是它已经不再运行。僵尸进程会占用系统的一些资源，包括进程号（PID）、进程表项和一部分内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Fork failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child process: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 子进程执行一些任务</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child process finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parent process: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 父进程没有进行wait操作</span></span><br><span class="line">        <span class="comment">// wait(NULL);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父子进程都会执行到这里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><ul>
<li><strong>gcc</strong></li>
</ul>
<p>它是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。</p>
<ul>
<li>make</li>
</ul>
<p>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。</p>
<ul>
<li>makefile</li>
</ul>
<p>简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。</p>
<ul>
<li>cmake</li>
</ul>
<p>cmake根据一个叫CMakeLists.txt文件,可以更加简单的生成makefile文件给上面那个make用,能够跨平台生成对应平台能用的makefile，无需手动修改。</p>
<h3 id="makefile编写"><a href="#makefile编写" class="headerlink" title="makefile编写"></a>makefile编写</h3><p><strong>文件目录树</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">makefile_t/</span><br><span class="line">├──main.cpp</span><br><span class="line">├──factorial.cpp</span><br><span class="line">├──printhello.cpp</span><br><span class="line">└──functions.h</span><br></pre></td></tr></table></figure>

<p><strong>version1</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello: main.cpp printhello.cpp factorial.cpp</span><br><span class="line">	g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br></pre></td></tr></table></figure>

<p><strong>version2</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(TARGET): $(OBJ)</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(CXX) -o $(TARGET) $(OBJ)</span></span><br><span class="line"></span><br><span class="line">main.o: main.cpp</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(CXX) -c main.cpp</span></span><br><span class="line"></span><br><span class="line">printhello.o: printhello.cpp</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(CXX) -c printhello.cpp</span></span><br><span class="line"></span><br><span class="line">factorial.o: factorial.cpp</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(CXX) -c factorial.cpp</span></span><br></pre></td></tr></table></figure>

<p><strong>version3</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(TARGET): $(OBJ)</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(CXX) -o <span class="variable">$@</span> $^</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.o: %.cpp</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(CXX) $(CXXFLAGS) $&lt; -o <span class="variable">$@</span></span></span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">	rm -f *.o $(TARGET)</span><br></pre></td></tr></table></figure>

<p><strong>version4</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line">SRC = $(wildcard *.cpp)</span><br><span class="line">OBJ = $(patsubst %.cpp, %.o, $(SRC))</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(TARGET): $(OBJ)</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(CXX) -o <span class="variable">$@</span> $^</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.o: %.cpp</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(CXX) $(CXXFLAGS) $&lt; -o <span class="variable">$@</span></span></span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">	rm -f *.o $(TARGET)</span><br></pre></td></tr></table></figure>

<p>.PHONY，makefile的特殊变量，用于生成“伪目标”。make中的“目标”通常指文件，但有时功能和文件名会重叠。以clean为例，我们需要clean来清除全部的中间文件，但同时我们不需要真的生成一个名为”clean”文件，所以当目标文件夹存在一个“clean”文件时，“clean”功能就不会被执行，所以需要一个”伪目标”去执行“clean”功能。</p>
<p>wildcard，用于防止通配符解析失败。使变量定义时，括号里的通配符仍然生效。</p>
<p>patsubst，用于防止替换文件解析失效。替换文件后缀。</p>
<h3 id="CMakeLists-txt编写"><a href="#CMakeLists-txt编写" class="headerlink" title="CMakeLists.txt编写"></a><strong>CMakeLists.txt编写</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line">project(makefile_t)</span><br><span class="line">add_executable(main ./src/main.cpp ./src/factorial.cpp ./src/printhello.cpp)</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="juzi">JuZi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://juzihhu.github.io/2023/12/25/ResumeNote/">http://juzihhu.github.io/2023/12/25/ResumeNote/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://juzihhu.github.io" target="_blank">JuZi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/p9/wallhaven-p9o51m.png" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/12/25/math/" title=""><img class="cover" src="https://cdn.pixabay.com/photo/2022/09/07/17/26/vintage-pocket-watch-7439233_960_720.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODEyMi8zNDU4NQ"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JuZi</div><div class="author-info__description">用技术创造美好，用生活感受美好</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/juzihhu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/juzihhu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:juzi.pan.an@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/383439781?spm_id_from=333.337.0.0" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome !</br> JuZi Blog !</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81c-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一、c++基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">C++程序执行的内存空间结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">在main执行之前和之后执行的代码可能是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#define-%E3%80%81inline%E3%80%81typedef-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">define 、inline、typedef 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#include%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">#include的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E4%B8%8E-malloc"><span class="toc-number">1.5.</span> <span class="toc-text">new 与 malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97"><span class="toc-number">1.6.</span> <span class="toc-text">malloc线程安全吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">1.7.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0f-int-a-int-b-%E7%9A%84b%E5%92%8Ca%E7%9A%84%E5%9C%B0%E5%9D%80%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">一个函数f(int a, int b)的b和a的地址关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE-%E4%B8%8E%E5%90%8E%E7%BD%AE"><span class="toc-number">1.9.</span> <span class="toc-text">前置++与后置++</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.10.</span> <span class="toc-text">左值引用与右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89std-move"><span class="toc-number">1.11.</span> <span class="toc-text">移动语义std::move()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91std-forward-lt-gt"><span class="toc-number">1.12.</span> <span class="toc-text">完美转发std::forward&lt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyString%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.13.</span> <span class="toc-text">MyString实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.14.</span> <span class="toc-text">string的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit"><span class="toc-number">1.15.</span> <span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcpy"><span class="toc-number">1.16.</span> <span class="toc-text">strcpy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8-x2F-%E6%8C%87%E9%92%88"><span class="toc-number">1.17.</span> <span class="toc-text">指向指针的引用&#x2F;指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E5%92%8C-int-a-x3D-b-%E5%9C%A8C-%E4%B8%AD%E6%98%AF%E5%90%A6%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.18.</span> <span class="toc-text">a++ 和 int a &#x3D; b 在C++中是否是线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">1.19.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.20.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BF%85%E9%A1%BB%E8%A6%81%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">析构函数是不是必须要为虚函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.22.</span> <span class="toc-text">为什么构造函数不能是虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%88%B0-vfunc1-%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">1.23.</span> <span class="toc-text">如何从虚函数表中查找到 vfunc1 的地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E6%84%8F%E4%B9%89-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.24.</span> <span class="toc-text">纯虚函数的实现以及意义 为什么析构函数可以是纯虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.25.</span> <span class="toc-text">什么是虚继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">shared_ptr线程是否安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">1.27.</span> <span class="toc-text">shared_ptr循环引用怎么解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.28.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.29.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E5%92%8Cdecltype%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.30.</span> <span class="toc-text">auto和decltype的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-amp-%E6%82%AC%E6%8C%82%E6%8C%87%E9%92%88%EF%BC%88%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%89%E7%9A%84%E5%8D%B1%E5%AE%B3%E5%8F%8A%E9%81%BF%E5%85%8D"><span class="toc-number">1.31.</span> <span class="toc-text">内存泄漏&amp;悬挂指针（野指针）的危害及避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-number">1.32.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E6%89%A9%E5%AE%B9%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">1.33.</span> <span class="toc-text">vector扩容与迭代器失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E6%89%A9%E5%AE%B9%EF%BC%8Cresize%E5%92%8Creserve%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.34.</span> <span class="toc-text">vector扩容，resize和reserve的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push-back%E5%92%8Cemplace-back"><span class="toc-number">1.35.</span> <span class="toc-text">push_back和emplace_back</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.36.</span> <span class="toc-text">const 成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.37.</span> <span class="toc-text">C++类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">2.</span> <span class="toc-text">二、计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">2.1.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">键入网址到网页显示，期间发生了什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%AF%87"><span class="toc-number">2.2.</span> <span class="toc-text">HTTP篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%90%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E3%80%8CHTTP%E3%80%8D%EF%BC%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">能否详细解释「HTTP」？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">HTTP 常见的状态码有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">HTTP 常见字段有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">GET 和 POST 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E4%B8%8E-HTTPS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.5.</span> <span class="toc-text">HTTP 与 HTTPS 有哪些区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS-%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.6.</span> <span class="toc-text">HTTPS 一定安全可靠吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-x2F-1-0%E3%80%81HTTP-x2F-1-1%E3%80%81HTTP-x2F-2%E3%80%81HTTP-x2F-3%E6%BC%94%E5%8F%98"><span class="toc-number">2.2.7.</span> <span class="toc-text">HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3演变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4-DNS%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.8.</span> <span class="toc-text">DNS详细说说?DNS用的什么协议?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.9.</span> <span class="toc-text">长连接和短连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session%E4%B8%8Ecookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.10.</span> <span class="toc-text">session与cookie的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%AF%87"><span class="toc-number">2.3.</span> <span class="toc-text">TCP篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是 TCP 连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP-%E5%92%8C-TCP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F%E5%88%86%E5%88%AB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%EF%BC%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">UDP 和 TCP 有什么区别呢？分别的应用场景是？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.3.</span> <span class="toc-text">TCP 和 UDP 可以使用同一个端口吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.3.4.</span> <span class="toc-text">TCP三次握手与四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.5.</span> <span class="toc-text">第三次握手丢失了，会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">2.3.6.</span> <span class="toc-text">为什么需要 TIME_WAIT 状态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TIME-WAIT-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2MSL%EF%BC%9F"><span class="toc-number">2.3.7.</span> <span class="toc-text">为什么 TIME_WAIT 等待的时间是 2MSL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8-close-%E4%BA%86%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%98%AF%E6%96%AD%E5%BC%80%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.8.</span> <span class="toc-text">客户端调用 close 了，连接是断开的流程是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-CLOSE-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.3.9.</span> <span class="toc-text">服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">2.3.10.</span> <span class="toc-text">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.11.</span> <span class="toc-text">如果已经建立了连接，但是服务端的进程崩溃会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.12.</span> <span class="toc-text">TCP重传机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88UDP%E4%B8%8D%E7%B2%98%E5%8C%85%EF%BC%9FIP-%E5%B1%82%E6%9C%89%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.13.</span> <span class="toc-text">TCP粘包是什么？ 为什么UDP不粘包？IP 层有粘包问题吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ssh%E7%9A%84%E5%85%AC%E9%92%A5%E4%B8%8E%E7%A7%81%E9%92%A5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.3.14.</span> <span class="toc-text">ssh的公钥与私钥的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%EF%BC%9F"><span class="toc-number">2.3.15.</span> <span class="toc-text">怎么判断网络拥塞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.16.</span> <span class="toc-text">如何理解TCP滑动窗口与拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">2.3.16.1.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.16.2.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.16.3.</span> <span class="toc-text">拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%BD%93%E5%89%8D%E7%BD%91%E7%BB%9C%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0%E4%BA%86%E6%8B%A5%E5%A1%9E%E5%91%A2%EF%BC%9F"><span class="toc-number">2.3.16.3.1.</span> <span class="toc-text">那么怎么知道当前网络是否出现了拥塞呢？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">2.3.16.3.2.</span> <span class="toc-text">拥塞控制有哪些控制算法？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%88Congestion-Control%EF%BC%89%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88Flow-Control%EF%BC%89"><span class="toc-number">2.3.16.3.3.</span> <span class="toc-text">TCP拥塞控制（Congestion Control）和流量控制（Flow Control）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.3.17.</span> <span class="toc-text">TCP如何保证可靠的连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84"><span class="toc-number">2.3.18.</span> <span class="toc-text">UDP连接为什么是不可靠的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A2%E7%84%B6-IP-%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81-MSS-%E5%91%A2%EF%BC%9F"><span class="toc-number">2.3.19.</span> <span class="toc-text">既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.20.</span> <span class="toc-text">Git分支管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">2.3.21.</span> <span class="toc-text">TCP 半连接队列和全连接队列？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-TCP"><span class="toc-number">2.3.22.</span> <span class="toc-text">如何优化 TCP?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.22.1.</span> <span class="toc-text">三次握手的性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.22.2.</span> <span class="toc-text">四次挥手的性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-number">2.3.22.3.</span> <span class="toc-text">数据传输的性能提升</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%98%AF-TCP-%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">2.3.23.</span> <span class="toc-text">如何理解是 TCP 面向字节流协议？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84TCP%EF%BC%8C%E6%94%B6%E5%88%B0SYN%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">已建立连接的TCP，收到SYN会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E7%AF%87"><span class="toc-number">2.5.</span> <span class="toc-text">IP篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81IP%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97"><span class="toc-number">2.5.1.</span> <span class="toc-text">常见IP相关计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">三、操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">CPU 是如何执行程序的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84-Cache%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%BA%A7Cache"><span class="toc-number">3.1.2.</span> <span class="toc-text">Cache是干什么的?Cache基于什么?为什么要设置多级Cache?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E8%AE%A9-CPU-%E8%B7%91%E5%BE%97%E6%9B%B4%E5%BF%AB%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">如何写出让 CPU 跑得更快的代码？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.3.</span> <span class="toc-text">进程通信的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.</span> <span class="toc-text">线程通信与进程通信的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-number">3.6.</span> <span class="toc-text">用户空间与内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98"><span class="toc-number">3.7.</span> <span class="toc-text">数据在内核与用户空间的拷贝问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.</span> <span class="toc-text">四、数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">数据库连接问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GROUP-BY%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">GROUP BY的相关使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">SQL 查询语句执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">4.4.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E5%AD%98%E5%82%A8%E4%B8%8E%E7%A3%81%E7%9B%98IO%E5%85%B3%E7%B3%BB"><span class="toc-number">4.4.1.</span> <span class="toc-text">树形存储与磁盘IO关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84-B-Tree-%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84-B-Tree-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.2.</span> <span class="toc-text">主键索引的 B+Tree 和二级索引的 B+Tree 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-MySQL-InnoDB-%E9%80%89%E6%8B%A9-B-tree-%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">4.4.3.</span> <span class="toc-text">为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%8C%89%E5%AD%97%E6%AE%B5%E7%89%B9%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">4.4.4.</span> <span class="toc-text">索引按字段特性分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AF%87"><span class="toc-number">4.5.</span> <span class="toc-text">事务篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">4.5.1.</span> <span class="toc-text">事务的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.5.2.</span> <span class="toc-text">并行事务会引发什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">4.5.3.</span> <span class="toc-text">事务隔离级别是怎么实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-View-%E5%9C%A8-MVCC-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">4.5.4.</span> <span class="toc-text">Read View 在 MVCC 里如何工作的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%EF%BC%9F"><span class="toc-number">4.5.5.</span> <span class="toc-text">MySQL 有哪些锁？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">五、算法与数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93"><span class="toc-number">5.1.</span> <span class="toc-text">背包总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="toc-number">5.2.</span> <span class="toc-text">剑指 Offer 30. 包含min函数的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HDU-ACM-1446-%E8%AE%A1%E7%AE%97%E7%9B%B4%E7%BA%BF%E7%9A%84%E4%BA%A4%E7%82%B9%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">HDU ACM:1446 计算直线的交点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E2%80%94%E2%80%94%E5%85%AC%E5%BC%8F%E6%B3%95%EF%BC%88%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">约瑟夫环——公式法（递推公式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%80%E9%87%8F%E9%97%AE%E9%A2%98"><span class="toc-number">5.5.</span> <span class="toc-text">血量问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.</span> <span class="toc-text">牛顿迭代法求平方根代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95"><span class="toc-number">5.7.</span> <span class="toc-text">LRU缓存算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92%EF%BC%9B%E7%A8%B3%E5%AE%9A%E7%89%88%E6%9C%AC%E5%BF%AB%E6%8E%92%EF%BC%9B%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92%EF%BC%9B"><span class="toc-number">5.8.</span> <span class="toc-text">快排；稳定版本快排；三路快排；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">5.9.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">5.10.</span> <span class="toc-text">合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">5.11.</span> <span class="toc-text">合并k个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8Ctarget%EF%BC%8C%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C-x3D-target%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">5.12.</span> <span class="toc-text">给定一棵二叉树和target，输出路径之和&#x3D;target的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">5.13.</span> <span class="toc-text">最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">5.14.</span> <span class="toc-text">最长无重复子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="toc-number">5.15.</span> <span class="toc-text">最长公共子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">5.16.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">5.17.</span> <span class="toc-text">编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.18.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-number">5.19.</span> <span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%E4%B8%8B%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="toc-number">5.19.1.</span> <span class="toc-text">内存限制下查找数组的重复数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%A1%B9%E7%9B%AE"><span class="toc-number">6.</span> <span class="toc-text">六、项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%AE%AB%E5%8A%A8%E8%84%89%E6%A0%93%E5%A1%9E%E4%BB%BF%E7%9C%9F"><span class="toc-number">6.1.</span> <span class="toc-text">子宫动脉栓塞仿真</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unet%E3%80%81Res-Unet-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.1.</span> <span class="toc-text">Unet、Res_Unet 原理与区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Marching-Cubes%E7%AE%97%E6%B3%95%E5%92%8C%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%BD%91%E6%A0%BC%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">Marching Cubes算法和拉普拉斯网格优化算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unity%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.1.3.</span> <span class="toc-text">unity粒子系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webserver"><span class="toc-number">6.2.</span> <span class="toc-text">webserver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%9A%BE%E7%82%B9"><span class="toc-number">6.2.2.</span> <span class="toc-text">改进过程中遇到的难点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket"><span class="toc-number">6.2.3.</span> <span class="toc-text">socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">6.2.4.</span> <span class="toc-text">IO复用技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ET%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-number">6.2.5.</span> <span class="toc-text">为什么ET模式下一定要设置非阻塞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E7%BD%AE%E6%88%90%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%EF%BC%9F"><span class="toc-number">6.2.6.</span> <span class="toc-text">监听套接字为什么要设置成非阻塞的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EPOLLONESHOT"><span class="toc-number">6.2.7.</span> <span class="toc-text">EPOLLONESHOT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%9F%E6%88%90%E5%93%8D%E5%BA%94%EF%BC%8C%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E8%BF%99%E4%B8%AA%E5%93%8D%E5%BA%94%E6%98%AF%E5%90%A6%E5%AE%8C%E6%95%B4%E7%84%B6%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">6.2.8.</span> <span class="toc-text">发送一个HTTP请求，服务器生成响应，怎么判断这个响应是否完整然后浏览器进行渲染？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%87%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E4%B8%8D%E5%AE%8C%E6%95%B4%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%EF%BC%9F"><span class="toc-number">6.2.9.</span> <span class="toc-text">项目里如果一个HTTP请求不完整怎么判断？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%98%AF%E6%9C%89%E5%90%8D%E8%BF%98%E6%98%AF%E5%8C%BF%E5%90%8D%EF%BC%9F"><span class="toc-number">6.2.10.</span> <span class="toc-text">内存映射是有名还是匿名？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.11.</span> <span class="toc-text">两种事件的处理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.12.</span> <span class="toc-text">线程池设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#std-shared-ptr-lt-Pool-gt-pool"><span class="toc-number">6.2.12.1.</span> <span class="toc-text">std::shared_ptr&lt;Pool&gt; pool_;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pool-gt-cond-notify-one-%EF%BC%9A"><span class="toc-number">6.2.12.2.</span> <span class="toc-text">pool_-&gt;cond.notify_one() ：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutex%EF%BC%89%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition-Variable%EF%BC%89"><span class="toc-number">6.2.12.3.</span> <span class="toc-text">互斥锁（Mutex）和条件变量（Condition Variable）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90"><span class="toc-number">6.2.13.</span> <span class="toc-text">HTTP请求解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%A2%9E%E9%95%BF%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">6.2.14.</span> <span class="toc-text">现自动增长的缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">6.2.15.</span> <span class="toc-text">小根堆实现的定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.2.16.</span> <span class="toc-text">利用单例模式与阻塞队列实现异步的日志系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="toc-number">6.2.17.</span> <span class="toc-text">线程池的线程数量一般怎么设置？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">6.2.18.</span> <span class="toc-text">数据库连接池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%B1%BB%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.19.</span> <span class="toc-text">并发编程中常见的三类并发问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.</span> <span class="toc-text">七、自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%B5%8B%E8%AF%95%E5%B2%97%E4%BD%8D"><span class="toc-number">8.</span> <span class="toc-text">八、测试岗位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E4%B8%8E%E7%99%BD%E7%9B%92%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">黑盒与白盒的测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E9%97%AE"><span class="toc-number">8.2.</span> <span class="toc-text">反问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">九、网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thread%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">thread的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join%E4%B8%8Edetach"><span class="toc-number">9.2.</span> <span class="toc-text">join与detach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0"><span class="toc-number">9.3.</span> <span class="toc-text">多线程交替打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%B9%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E5%86%85%E7%9A%84%E6%95%B0%E5%AD%97%E6%B1%82%E5%92%8C"><span class="toc-number">9.4.</span> <span class="toc-text">多线程对多个文件内的数字求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A1%AE%E4%BF%9D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">9.5.</span> <span class="toc-text">C++确保线程安全的几种方式？代码举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">9.6.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">9.7.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B2%A1%E6%9C%89wait%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">9.8.</span> <span class="toc-text">Linux子进程创建没有wait操作会发生什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmake"><span class="toc-number">10.</span> <span class="toc-text">cmake</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#makefile%E7%BC%96%E5%86%99"><span class="toc-number">10.1.</span> <span class="toc-text">makefile编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMakeLists-txt%E7%BC%96%E5%86%99"><span class="toc-number">10.2.</span> <span class="toc-text">CMakeLists.txt编写</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/25/ResumeNote/" title="pytorch+gpu 环境配置"><img src="https://w.wallhaven.cc/full/p9/wallhaven-p9o51m.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pytorch+gpu 环境配置"/></a><div class="content"><a class="title" href="/2023/12/25/ResumeNote/" title="pytorch+gpu 环境配置">pytorch+gpu 环境配置</a><time datetime="2023-12-25T12:37:37.535Z" title="发表于 2023-12-25 20:37:37">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/25/math/" title="无题"><img src="https://cdn.pixabay.com/photo/2022/09/07/17/26/vintage-pocket-watch-7439233_960_720.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/12/25/math/" title="无题">无题</a><time datetime="2023-12-25T12:37:37.520Z" title="发表于 2023-12-25 20:37:37">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/25/Interview%20summary/" title="无题"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/12/25/Interview%20summary/" title="无题">无题</a><time datetime="2023-12-25T12:37:37.514Z" title="发表于 2023-12-25 20:37:37">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/25/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/" title="无题"><img src="https://cdn.pixabay.com/photo/2022/09/07/17/26/vintage-pocket-watch-7439233_960_720.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/12/25/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/" title="无题">无题</a><time datetime="2023-12-25T12:37:37.503Z" title="发表于 2023-12-25 20:37:37">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/25/Detailed%20explanation%20of%20interview%20questions/" title="无题"><img src="https://cdn.pixabay.com/photo/2022/09/07/17/26/vintage-pocket-watch-7439233_960_720.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/12/25/Detailed%20explanation%20of%20interview%20questions/" title="无题">无题</a><time datetime="2023-12-25T12:37:37.496Z" title="发表于 2023-12-25 20:37:37">2023-12-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://w.wallhaven.cc/full/p9/wallhaven-p9o51m.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By JuZi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://juzihhu.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'PMLA4YCVqwdSVlHuF4PenwKR-gzGzoHsz',
      appKey: '6on0ibbvwxIv2VwFkcFvR6bR',
      avatar: 'monsterid',
      serverURLs: 'https://pmla4ycv.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Valine' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(function(d, w, c) {
    w.ChatraID = 'Tat3ZsRebPQGuczXg';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>